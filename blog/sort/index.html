<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="default-src 'self';font-src 'self' data:;img-src 'self' https://* data:;media-src 'self';style-src 'self';frame-src player.vimeo.com https://www.youtube-nocookie.com;connect-src 'self';script-src 'self' 'self'" http-equiv=Content-Security-Policy><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://bieyuanxi.github.io name=base><title>
Terra's Blog • 内部排序</title><link title="Terra's Blog - Atom Feed" href=https://bieyuanxi.github.io/atom.xml rel=alternate type=application/atom+xml><link href="https://bieyuanxi.github.io/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://bieyuanxi.github.io/main.css?h=045c365e19a4d50a64bb" rel=stylesheet><meta content="light dark" name=color-scheme><meta content=YOUR_SITE_DESCRIPTION name=description><meta content=YOUR_SITE_DESCRIPTION property=og:description><meta content=内部排序 property=og:title><meta content=article property=og:type><meta content=en_GB property=og:locale><meta content=https://bieyuanxi.github.io/blog/sort/ property=og:url><meta content="Terra's Blog" property=og:site_name><noscript><link href=https://bieyuanxi.github.io/no_js.css rel=stylesheet></noscript><script src=https://bieyuanxi.github.io/js/initializeTheme.min.js></script><script defer src=https://bieyuanxi.github.io/js/themeSwitcher.min.js></script><script src="https://bieyuanxi.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><a href=#main-content id=skip-link>Skip to content</a><header><nav class=navbar><div class=nav-title><a class=home-title href=https://bieyuanxi.github.io/>Terra's Blog</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://bieyuanxi.github.io/blog/>blog </a><li><a class="nav-links no-hover-padding" href=https://bieyuanxi.github.io/archive/>archive </a><li><a class="nav-links no-hover-padding" href=https://bieyuanxi.github.io/tags/>tags </a><li><a class="nav-links no-hover-padding" href=https://bieyuanxi.github.io/projects/>projects </a><li class=menu-icons-container><ul class=menu-icons-group><li class="js menu-icon"><div aria-label="Click or press $SHORTCUT to open search" class="search-icon interactive-icon" title="Click or press $SHORTCUT to open search" id=search-button role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><li class="theme-switcher-wrapper js"><div aria-label="Toggle dark mode" title="Toggle dark/light mode" aria-pressed=false class=theme-switcher role=button tabindex=0></div><div aria-label="Reset mode to default" class="theme-resetter arrow" title="Reset mode to default" aria-hidden=true role=button tabindex=0></div></ul></ul></div></nav></header><div class=content id=main-content><main><article class=h-entry><h1 class="p-name article-title">内部排序</h1><a class="u-url u-uid" href=https://bieyuanxi.github.io/blog/sort/></a><ul class=meta><span class="hidden p-author h-card"> <a class=u-url href=https://bieyuanxi.github.io rel=author title=Terra>Terra</a> </span><li><time class=dt-published datetime=2023-11-18>18th Nov 2023</time><li title="1171 words"><span aria-hidden=true class=separator>•</span>6 min read<li class=tag><span aria-hidden=true class=separator>•</span>Tags: <li class=tag><a class=p-category href=https://bieyuanxi.github.io/tags/pai-xu/>排序</a></ul><section class="e-content body"><h1 id=nei-bu-pai-xu>内部排序</h1><ol><li>稳定、不稳定<li></ol><pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-storage z-type">typedef int</span><span> ElemType;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    ElemType *buf;</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> len;</span></span>
<span class=giallo-l><span>} SqList;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>// a是index较小的元素的地址，b是index较大的元素的地址</span></span>
<span class=giallo-l><span class=z-comment>// 返回值>0： 交换a、b的值</span></span>
<span class=giallo-l><span class=z-comment>// 返回值=0： a、b相等</span></span>
<span class=giallo-l><span class=z-comment>// 返回值&lt;0： 不交换a、b的值</span></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef int</span><span class="z-keyword z-operator"> (*cmp)(</span><span class="z-storage z-modifier z-storage z-type">const void</span><span class="z-keyword z-operator"> *a,</span><span class="z-storage z-modifier z-storage z-type"> const void</span><span class="z-keyword z-operator"> *b);</span></span></code></pre><h2 id=fen-lei>分类</h2><p>按照排序过程中依据的不同原则：<ol><li>插入排序：直接插入排序、折半插入排序、希尔排序<li>交换排序：冒泡排序、快速排序<li>选择排序：简单选择排序、堆排序<li>归并排序<li>计数排序：基于分配和收集。</ol><h2 id=cha-ru-pai-xu>插入排序</h2><p>将序列看成已排序+未排序两部分，每次从未排序部分选取一个插入到已排序的序列，初始约定序列第一个元素已排序。<h3 id=zhi-jie-cha-ru-pai-xu>直接插入排序</h3><ol><li>分类：插入排序<li>适用范围：适合长度n较小的序列、基本有序的序列<li>适用数据结构：适用于顺序表、链表<li>时间复杂度： <ul><li>平均：O($n^2$)<li>最好：O($n$)：原本有序<li>最坏：O($n^2$)：原本逆序</ul><li>空间复杂度：O(1)<li>稳定性：稳定</ol><pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class=z-comment>// 直接插入排序</span></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> insert_sort</span><span class="z-keyword z-operator">(SqList *</span><span class=z-variable>list</span><span>, cmp </span><span class=z-variable>compare</span><span>) {</span></span>
<span class=giallo-l><span>    ElemType temp;</span></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span> (</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> i =</span><span class="z-constant z-numeric"> 1</span><span class="z-keyword z-operator">; i &lt;</span><span class=z-variable> list</span><span>-></span><span class=z-variable>len</span><span class="z-keyword z-operator">; ++i) {</span><span class=z-comment>   //从i=1开始</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        temp =</span><span class=z-variable> list</span><span>-></span><span class=z-variable>buf</span><span>[i];</span><span class=z-comment>    //暂存</span></span>
<span class=giallo-l><span class="z-storage z-type">        int</span><span class="z-keyword z-operator"> j = i;</span></span>
<span class=giallo-l><span class="z-keyword z-control">        for</span><span class="z-keyword z-operator"> (; j ></span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator"> &&</span><span class="z-entity z-name z-function"> compare</span><span>(</span><span class=z-variable>list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator"> + j -</span><span class="z-constant z-numeric"> 1</span><span class="z-keyword z-operator">, &temp) ></span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; --j) {</span></span>
<span class=giallo-l><span class=z-variable>            list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator">[j] =</span><span class=z-variable> list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator">[j -</span><span class="z-constant z-numeric"> 1</span><span>];</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span class=z-variable>        list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator">[j] = temp;</span><span class=z-comment>    //插入</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>### 折半插入排序</span></span>
<span class=giallo-l><span class="z-constant z-numeric">1.</span><span> 分类：插入排序</span></span>
<span class=giallo-l><span class="z-constant z-numeric">1.</span><span> 适用范围：初始序列基本无序</span></span>
<span class=giallo-l><span class="z-constant z-numeric">1.</span><span> 适用数据结构：仅适用于顺序表</span></span>
<span class=giallo-l><span class="z-constant z-numeric">1.</span><span> 时间复杂度：</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    * 平均：</span><span class="z-entity z-name z-function">O</span><span class="z-keyword z-operator">($n^</span><span class="z-constant z-numeric">2</span><span>$)</span></span>
<span class=giallo-l><span class="z-constant z-numeric">1.</span><span> 空间复杂度：</span><span class="z-entity z-name z-function">O</span><span>(</span><span class="z-constant z-numeric">1</span><span>)</span></span>
<span class=giallo-l><span class="z-constant z-numeric">1.</span><span> 稳定性：稳定</span></span>
<span class=giallo-l><span class=z-comment>// 折半插入排序</span></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> binary_insert_sort</span><span class="z-keyword z-operator">(SqList *</span><span class=z-variable>list</span><span>, cmp </span><span class=z-variable>cmp</span><span>) {</span></span>
<span class=giallo-l><span>    ElemType temp;</span></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span> (</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> i =</span><span class="z-constant z-numeric"> 1</span><span class="z-keyword z-operator">; i &lt;</span><span class=z-variable> list</span><span>-></span><span class=z-variable>len</span><span class="z-keyword z-operator">; ++i) {</span><span class=z-comment>   //从i=1开始</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        temp =</span><span class=z-variable> list</span><span>-></span><span class=z-variable>buf</span><span>[i];</span><span class=z-comment>    //暂存</span></span>
<span class=giallo-l><span class="z-storage z-type">        int</span><span class="z-keyword z-operator"> low =</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">, high = i -</span><span class="z-constant z-numeric"> 1</span><span>;</span></span>
<span class=giallo-l><span>        </span></span>
<span class=giallo-l><span class="z-keyword z-control">        while</span><span class="z-keyword z-operator"> (low &lt;= high) {</span></span>
<span class=giallo-l><span class="z-storage z-type">            int</span><span class="z-keyword z-operator"> mid = (low + high) >></span><span class="z-constant z-numeric"> 1</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-control">            if</span><span> (</span><span class="z-entity z-name z-function">compare</span><span>(</span><span class=z-variable>list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator"> + mid, &temp) ></span><span class="z-constant z-numeric"> 0</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">                high = mid -</span><span class="z-constant z-numeric"> 1</span><span>;</span></span>
<span class=giallo-l><span>            }</span><span class="z-keyword z-control">else</span><span> {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">                low = mid +</span><span class="z-constant z-numeric"> 1</span><span>;</span></span>
<span class=giallo-l><span>            }</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span class="z-storage z-type">        int</span><span class="z-keyword z-operator"> j = i;</span></span>
<span class=giallo-l><span class="z-keyword z-control">        for</span><span class="z-keyword z-operator"> (; j > low; --j) {  </span></span>
<span class=giallo-l><span class=z-variable>            list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator">[j] =</span><span class=z-variable> list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator">[j -</span><span class="z-constant z-numeric"> 1</span><span>];</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span class=z-variable>        list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator">[j] = temp;</span><span class=z-comment>    //  在low(或者high+1)的位置插入</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span></code></pre><h2 id=xi-er-pai-xu-suo-xiao-zeng-liang-pai-xu>希尔排序/缩小增量排序</h2><p>增量序列最好是质数序列（避免前几次都是无效排序），且序列最后一位是1<ol><li>分类：插入排序<li>适用范围：适合长度n较大的序列<li>适用数据结构：仅适用于顺序表<li>时间复杂度： <ul><li>平均：O($n^{1.3}$)</ul><li>空间复杂度：O(1)<li>稳定性：不稳定</ol><p>不怎么考察代码，常考的题目：给出增量序列，分析每一趟排序后的状态<pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> shell_sort</span><span class="z-keyword z-operator">(SqList *</span><span class=z-variable>list</span><span>, cmp </span><span class=z-variable>cmp</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span> (</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> step =</span><span class=z-variable> list</span><span>-></span><span class=z-variable>len</span><span class="z-keyword z-operator"> >></span><span class="z-constant z-numeric"> 1</span><span class="z-keyword z-operator">; step ></span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; step >>=</span><span class="z-constant z-numeric"> 1</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">        for</span><span> (</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> i = step; i &lt;</span><span class=z-variable> list</span><span>-></span><span class=z-variable>len</span><span class="z-keyword z-operator">; i++) {</span><span class=z-comment>   //从i=1开始</span></span>
<span class=giallo-l><span class="z-storage z-type">            int</span><span class="z-keyword z-operator"> temp =</span><span class=z-variable> list</span><span>-></span><span class=z-variable>buf</span><span>[i];</span><span class=z-comment>    //暂存</span></span>
<span class=giallo-l><span class="z-storage z-type">            int</span><span class="z-keyword z-operator"> j = i;</span></span>
<span class=giallo-l><span class="z-keyword z-control">            for</span><span class="z-keyword z-operator"> (; j ></span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator"> &&</span><span class="z-entity z-name z-function"> compare</span><span>(</span><span class=z-variable>list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator"> + j - step, &temp) ></span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; j -= step) {</span></span>
<span class=giallo-l><span class=z-variable>                list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator">[j] =</span><span class=z-variable> list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator">[j - step];</span></span>
<span class=giallo-l><span>            }</span></span>
<span class=giallo-l><span class=z-variable>            list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator">[j] = temp;</span><span class=z-comment>    //插入</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span></code></pre><h2 id=mou-pao-pai-xu>冒泡排序</h2><ol><li>分类：交换排序<li>适用范围：n较小时<li>适用数据结构：适用于顺序表、链表<li>时间复杂度： <ul><li>平均：O($n^2$)<li>最好：O($n$)：原本有序<li>最坏：O($n^2$)：原本逆序</ul><li>空间复杂度：O(1)<li>稳定性：稳定</ol><pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> bubble_sort</span><span class="z-keyword z-operator">(SqList *</span><span class=z-variable>list</span><span>, cmp </span><span class=z-variable>cmp</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span> (</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> i =</span><span class=z-variable> list</span><span>-></span><span class=z-variable>len</span><span class="z-keyword z-operator"> -</span><span class="z-constant z-numeric"> 1</span><span class="z-keyword z-operator">; i ></span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; --i) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">        for</span><span> (</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> j =</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; j &lt; i; ++j) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">            if</span><span> (</span><span class="z-entity z-name z-function">cmp</span><span>(</span><span class=z-variable>list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator"> + j,</span><span class=z-variable> list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator"> + j +</span><span class="z-constant z-numeric"> 1</span><span class="z-keyword z-operator">) ></span><span class="z-constant z-numeric"> 0</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">                ElemType temp =</span><span class=z-variable> list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator">[j +</span><span class="z-constant z-numeric"> 1</span><span>];</span></span>
<span class=giallo-l><span class=z-variable>                list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator">[j +</span><span class="z-constant z-numeric"> 1</span><span class="z-keyword z-operator">] =</span><span class=z-variable> list</span><span>-></span><span class=z-variable>buf</span><span>[j];</span></span>
<span class=giallo-l><span class=z-variable>                list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator">[j] = temp;</span></span>
<span class=giallo-l><span>            }</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span></code></pre><h2 id=kuai-su-pai-xu>快速排序</h2><ol><li>分类：交换排序<li>适用范围：n较大、无序（不适用于逆序或基本有序）<li>适用数据结构：仅适用于顺序表<li>时间复杂度： <ul><li>平均：O($n\log_2{n}$)：平均性能最优<li>最好：O($n\log_2{n}$)：原本有序<li>最坏：O($n^2$)：原本逆序，退化为冒泡排序</ul><li>空间复杂度：取决于递归深度，每次“划分”越均匀，递归深度越低 <ul><li>最好：O($\log_2{n}$)<li>最坏：O($n$)</ul><li>稳定性：不稳定<li>优化方法： <ol><li>n较小时改用直接插入；<li>事先遍历确保无序（或者做标记，找到枢纽时标记未反转表示有序或逆序）；<li>三者取中：用首位、中间、尾位元素的中间值替换首个元素，避免有序情况；<li>针对分割后长度较短的先排序，空间复杂度可降至O($\log_2{n}$)</ol></ol><p>手写提技巧：给出每一趟排序结果时，只需要<pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class=z-comment>// [start, end) 左闭右开</span></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> _quick_sort_rec</span><span class="z-keyword z-operator">(ElemType *</span><span class=z-variable>buf</span><span>,</span><span class="z-storage z-modifier z-storage z-type"> const int</span><span class=z-variable> start</span><span>,</span><span class="z-storage z-modifier z-storage z-type"> const int</span><span class=z-variable> end</span><span>, cmp </span><span class=z-variable>cmp</span><span>) {</span></span>
<span class=giallo-l><span class=z-comment>    // 优化：长度小于8,改用直接插入TODO</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-control">    if</span><span class="z-keyword z-operator"> (end -start &lt;=</span><span class="z-constant z-numeric"> 1</span><span>)</span><span class="z-keyword z-control"> return</span><span>;</span><span class=z-comment>    // 长度为1,结束</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>    // 优化：事先遍历，确保不是有序TODO</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class="z-keyword z-operator"> lp = start, rp = end -</span><span class="z-constant z-numeric"> 1</span><span>;</span></span>
<span class=giallo-l><span class=z-comment>    // 优化：交换中间元素和头元素，随机化，避免有序情况</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class="z-keyword z-operator"> mid = (start + end) >></span><span class="z-constant z-numeric"> 1</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    ElemType temp =</span><span class=z-variable> buf</span><span>[mid];</span></span>
<span class=giallo-l><span class=z-variable>    buf</span><span class="z-keyword z-operator">[mid] =</span><span class=z-variable> buf</span><span>[start];</span></span>
<span class=giallo-l><span class=z-variable>    buf</span><span class="z-keyword z-operator">[start] = temp;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-operator">    temp =</span><span class=z-variable> buf</span><span>[start];</span><span class=z-comment> // 暂存第一个，初始设置start位置为空</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-control">    while</span><span class="z-keyword z-operator"> (lp &lt; rp) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">        while</span><span class="z-keyword z-operator"> (lp &lt; rp &&</span><span class="z-entity z-name z-function"> cmp</span><span class="z-keyword z-operator">(&temp, buf + rp) &lt;=</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">) rp--;</span></span>
<span class=giallo-l><span class="z-keyword z-control">        if</span><span class="z-keyword z-operator">(lp != rp)</span><span class=z-variable> buf</span><span class="z-keyword z-operator">[lp] =</span><span class=z-variable> buf</span><span>[rp];</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-control">        while</span><span class="z-keyword z-operator"> (lp &lt; rp &&</span><span class="z-entity z-name z-function"> cmp</span><span class="z-keyword z-operator">(buf + lp, &temp) &lt;=</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">) lp++;</span></span>
<span class=giallo-l><span class="z-keyword z-control">        if</span><span class="z-keyword z-operator"> (lp != rp)</span><span class=z-variable> buf</span><span class="z-keyword z-operator">[rp] =</span><span class=z-variable> buf</span><span>[lp];</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span class=z-variable>    buf</span><span class="z-keyword z-operator">[lp] = temp;</span></span>
<span class=giallo-l><span class=z-comment>    // 得到枢纽lp=rp</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    _quick_sort_rec</span><span>(buf, start, lp, cmp);</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    _quick_sort_rec</span><span class="z-keyword z-operator">(buf, lp +</span><span class="z-constant z-numeric"> 1</span><span>, end, cmp);</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> quick_sort_rec</span><span class="z-keyword z-operator">(SqList *</span><span class=z-variable>list</span><span>, cmp </span><span class=z-variable>cmp</span><span>) {</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    _quick_sort_rec</span><span>(</span><span class=z-variable>list</span><span>-></span><span class=z-variable>buf</span><span>,</span><span class="z-constant z-numeric"> 0</span><span>,</span><span class=z-variable> list</span><span>-></span><span class=z-variable>len</span><span>, cmp);</span></span>
<span class=giallo-l><span>}</span></span></code></pre><h2 id=jian-dan-xuan-ze-pai-xu>(简单)选择排序</h2><p>每次选择一个最大/最小的加入有序序列。<ol><li>分类：选择排序<li>适用范围：<li>适用数据结构：适用于顺序表、链表<li>时间复杂度： <ul><li>平均：O($n^2$)：平均性能最优<li>最好：O($n^2$)：原本有序<li>最坏：O($n^2$)：原本逆序</ul><li>空间复杂度：O(1)<li>稳定性：不稳定</ol><pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> select_sort</span><span class="z-keyword z-operator">(SqList *</span><span class=z-variable>list</span><span>, cmp </span><span class=z-variable>cmp</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span> (</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> i =</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; i &lt;</span><span class=z-variable> list</span><span>-></span><span class=z-variable>len</span><span class="z-keyword z-operator">; ++i) {</span></span>
<span class=giallo-l><span class="z-storage z-type">        int</span><span class="z-keyword z-operator"> min = i;</span></span>
<span class=giallo-l><span class="z-keyword z-control">        for</span><span> (</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> j = i +</span><span class="z-constant z-numeric"> 1</span><span class="z-keyword z-operator">; j &lt;</span><span class=z-variable> list</span><span>-></span><span class=z-variable>len</span><span class="z-keyword z-operator">; ++j) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">            if</span><span> (</span><span class="z-entity z-name z-function">compare</span><span>(</span><span class=z-variable>list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator"> + min,</span><span class=z-variable> list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator"> + j) ></span><span class="z-constant z-numeric"> 0</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">                min = j;</span></span>
<span class=giallo-l><span>            }</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        ElemType temp =</span><span class=z-variable> list</span><span>-></span><span class=z-variable>buf</span><span>[min];</span></span>
<span class=giallo-l><span class=z-variable>        list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator">[min] =</span><span class=z-variable> list</span><span>-></span><span class=z-variable>buf</span><span>[i];</span></span>
<span class=giallo-l><span class=z-variable>        list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator">[i] = temp;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span></code></pre><h2 id=dui-pai-xu>堆排序</h2><p>堆排序的一些概念<ol><li>大顶堆：升序排序<li>小顶堆：降序排序</ol><hr><ol><li>分类：选择排序<li>适用范围：n较大<li>适用数据结构：适用于顺序表<li>时间复杂度： <ul><li>平均：O($n\log_2{n}$)：建堆：O(n)，排序（n次维护，每次$\log_2n$）：O($n\log_2{n}$)<li>最好：O($n\log_2{n}$)：<li>最坏：O($n\log_2{n}$)：</ul><li>空间复杂度：O(1)<li>稳定性：不稳定</ol><pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-control">#define</span><span class="z-entity z-name z-function z-preprocessor z-meta z-preprocessor"> LCHILD(</span><span class=z-variable>p</span><span class="z-meta z-preprocessor">) (((p)</span><span class="z-keyword z-operator"> &lt;&lt;</span><span class="z-constant z-numeric"> 1</span><span class="z-meta z-preprocessor">)</span><span class="z-keyword z-operator"> +</span><span class="z-constant z-numeric"> 1</span><span class="z-meta z-preprocessor">)</span></span>
<span class=giallo-l><span class="z-keyword z-control">#define</span><span class="z-entity z-name z-function z-preprocessor z-meta z-preprocessor"> RCHILD(</span><span class=z-variable>p</span><span class="z-meta z-preprocessor">) (((p)</span><span class="z-keyword z-operator"> &lt;&lt;</span><span class="z-constant z-numeric"> 1</span><span class="z-meta z-preprocessor">)</span><span class="z-keyword z-operator"> +</span><span class="z-constant z-numeric"> 2</span><span class="z-meta z-preprocessor">)</span></span>
<span class=giallo-l><span class="z-keyword z-control">#define</span><span class="z-entity z-name z-function z-preprocessor z-meta z-preprocessor"> PARENT(</span><span class=z-variable>child</span><span class="z-meta z-preprocessor">) (((child)</span><span class="z-keyword z-operator"> -</span><span class="z-constant z-numeric"> 1</span><span class="z-meta z-preprocessor">)</span><span class="z-keyword z-operator"> >></span><span class="z-constant z-numeric"> 1</span><span class="z-meta z-preprocessor">)</span></span>
<span class=giallo-l><span class="z-keyword z-control">#define</span><span class="z-entity z-name z-function z-preprocessor z-meta z-preprocessor"> CHILD_VALID(</span><span class=z-variable>child</span><span class="z-meta z-preprocessor">,</span><span class=z-variable> len</span><span class="z-meta z-preprocessor">) (child </span><span class="z-keyword z-operator">&lt;</span><span class="z-meta z-preprocessor"> len)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> _sink</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> *</span><span class=z-variable>buf</span><span>,</span><span class="z-storage z-type"> int</span><span class=z-variable> len</span><span>,</span><span class="z-storage z-type"> int</span><span class=z-variable> index</span><span>, cmp </span><span class=z-variable>cmp</span><span>) {</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class="z-keyword z-operator"> next = index;</span></span>
<span class=giallo-l><span class="z-keyword z-control">    while</span><span> (</span><span class="z-entity z-name z-function">CHILD_VALID</span><span>(</span><span class="z-entity z-name z-function">LCHILD</span><span>(index), len)) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">        if</span><span> (</span><span class="z-entity z-name z-function">compare</span><span class="z-keyword z-operator">(buf +</span><span class="z-entity z-name z-function"> LCHILD</span><span class="z-keyword z-operator">(index), buf + index) ></span><span class="z-constant z-numeric"> 0</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">            ElemType temp =</span><span class=z-variable> buf</span><span>[index];</span></span>
<span class=giallo-l><span class=z-variable>            buf</span><span class="z-keyword z-operator">[index] =</span><span class=z-variable> buf</span><span>[</span><span class="z-entity z-name z-function">LCHILD</span><span>(index)];</span></span>
<span class=giallo-l><span class=z-variable>            buf</span><span>[</span><span class="z-entity z-name z-function">LCHILD</span><span class="z-keyword z-operator">(index)] = temp;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">            next =</span><span class="z-entity z-name z-function"> LCHILD</span><span>(index);</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span class="z-keyword z-control">        if</span><span> (</span><span class="z-entity z-name z-function">CHILD_VALID</span><span>(</span><span class="z-entity z-name z-function">RCHILD</span><span>(index), len) </span></span>
<span class=giallo-l><span class="z-keyword z-operator">            &&</span><span class="z-entity z-name z-function"> compare</span><span class="z-keyword z-operator">(buf +</span><span class="z-entity z-name z-function"> RCHILD</span><span class="z-keyword z-operator">(index), buf + index) ></span><span class="z-constant z-numeric"> 0</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">            ElemType temp =</span><span class=z-variable> buf</span><span>[index];</span></span>
<span class=giallo-l><span class=z-variable>            buf</span><span class="z-keyword z-operator">[index] =</span><span class=z-variable> buf</span><span>[</span><span class="z-entity z-name z-function">RCHILD</span><span>(index)];</span></span>
<span class=giallo-l><span class=z-variable>            buf</span><span>[</span><span class="z-entity z-name z-function">RCHILD</span><span class="z-keyword z-operator">(index)] = temp;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">            next =</span><span class="z-entity z-name z-function"> RCHILD</span><span>(index);</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span class="z-keyword z-control">        if</span><span class="z-keyword z-operator"> (next == index)</span><span class="z-keyword z-control"> break</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        index = next;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> heap_sort</span><span class="z-keyword z-operator">(SqList *</span><span class=z-variable>list</span><span>, cmp </span><span class=z-variable>cmp</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span> (</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> i =</span><span class="z-entity z-name z-function"> PARENT</span><span>(</span><span class=z-variable>list</span><span>-></span><span class=z-variable>len</span><span class="z-keyword z-operator"> -</span><span class="z-constant z-numeric"> 1</span><span class="z-keyword z-operator">); i >=</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; --i) {</span><span class=z-comment>  //从最后一个有孩子的结点开始</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">        _sink</span><span>(</span><span class=z-variable>list</span><span>-></span><span class=z-variable>buf</span><span>,</span><span class=z-variable> list</span><span>-></span><span class=z-variable>len</span><span>, i, cmp);</span><span class=z-comment>    //构建堆</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    ElemType temp;</span></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span> (</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> i =</span><span class=z-variable> list</span><span>-></span><span class=z-variable>len</span><span class="z-keyword z-operator"> -</span><span class="z-constant z-numeric"> 1</span><span class="z-keyword z-operator">; i >=</span><span class="z-constant z-numeric"> 1</span><span class="z-keyword z-operator">; --i) {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        temp =</span><span class=z-variable> list</span><span>-></span><span class=z-variable>buf</span><span>[i];</span></span>
<span class=giallo-l><span class=z-variable>        list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator">[i] =</span><span class=z-variable> list</span><span>-></span><span class=z-variable>buf</span><span>[</span><span class="z-constant z-numeric">0</span><span>];</span></span>
<span class=giallo-l><span class=z-variable>        list</span><span>-></span><span class=z-variable>buf</span><span>[</span><span class="z-constant z-numeric">0</span><span class="z-keyword z-operator">] = temp;</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">        _sink</span><span>(</span><span class=z-variable>list</span><span>-></span><span class=z-variable>buf</span><span>, i,</span><span class="z-constant z-numeric"> 0</span><span>, cmp);</span><span class=z-comment>    //维护堆</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span></code></pre><h2 id=gui-bing-pai-xu>归并排序</h2><p>分治思想，将序列递归地分成两个已排好序的序列（递归到子序列长度为1），之后递归合并<ol><li>分类：归并排序<li>适用范围：n较大<li>适用数据结构：适用于顺序表<li>时间复杂度： <ul><li>平均：O($n\log_2{n}$)：分治:O($\log_2{n}$),合并O($n$)<li>最好：O($n\log_2{n}$)：<li>最坏：O($n\log_2{n}$)：</ul><li>空间复杂度：O($n$)：需要存储序列的值，以便合并<li>稳定性：稳定</ol><pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-control">#define</span><span class="z-entity z-name z-function z-preprocessor z-meta z-preprocessor"> MIN(</span><span class=z-variable>a</span><span class="z-meta z-preprocessor">,</span><span class=z-variable> b</span><span class="z-meta z-preprocessor">) ((a)</span><span class="z-keyword z-operator"> ></span><span class="z-meta z-preprocessor"> (b)</span><span class="z-keyword z-operator"> ?</span><span class="z-meta z-preprocessor"> (b)</span><span class="z-keyword z-operator"> :</span><span class="z-meta z-preprocessor"> (a))</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>// 非递归</span></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> merge_sort</span><span class="z-keyword z-operator">(SqList *</span><span class=z-variable>list</span><span>, cmp </span><span class=z-variable>cmp</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    ElemType *cache = (ElemType*)</span><span class="z-entity z-name z-function">malloc</span><span>(</span><span class="z-keyword z-operator z-sizeof">sizeof</span><span class="z-keyword z-operator">(ElemType) *</span><span class=z-variable> list</span><span>-></span><span class=z-variable>len</span><span>);</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span> (</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> step =</span><span class="z-constant z-numeric"> 1</span><span class="z-keyword z-operator">; step &lt;</span><span class=z-variable> list</span><span>-></span><span class=z-variable>len</span><span class="z-keyword z-operator">; step &lt;&lt;=</span><span class="z-constant z-numeric"> 1</span><span>) {</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">        memmove</span><span>(cache,</span><span class=z-variable> list</span><span>-></span><span class=z-variable>buf</span><span>,</span><span class="z-keyword z-operator z-sizeof"> sizeof</span><span class="z-keyword z-operator">(ElemType) *</span><span class=z-variable> list</span><span>-></span><span class=z-variable>len</span><span>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-control">        for</span><span> (</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> start =</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">, mid = start + step, end =</span><span class="z-entity z-name z-function"> MIN</span><span class="z-keyword z-operator">(mid + step,</span><span class=z-variable> list</span><span>-></span><span class=z-variable>len</span><span>);</span></span>
<span class=giallo-l><span class="z-keyword z-operator">            mid &lt;</span><span class=z-variable> list</span><span>-></span><span class=z-variable>len</span><span>; </span></span>
<span class=giallo-l><span class="z-keyword z-operator">            start = end, mid = start + step, end =</span><span class="z-entity z-name z-function"> MIN</span><span class="z-keyword z-operator">(mid + step,</span><span class=z-variable> list</span><span>-></span><span class=z-variable>len</span><span>)) {</span></span>
<span class=giallo-l><span>            </span></span>
<span class=giallo-l><span class="z-storage z-type">            int</span><span class="z-keyword z-operator"> i = start, p = start, j = mid;</span></span>
<span class=giallo-l><span class="z-keyword z-control">            while</span><span class="z-keyword z-operator"> (i &lt; mid && j &lt; end) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">                if</span><span> (</span><span class="z-entity z-name z-function">compare</span><span class="z-keyword z-operator">(cache + i, cache + j) ></span><span class="z-constant z-numeric"> 0</span><span>)</span><span class=z-variable> list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator">[p++] =</span><span class=z-variable> cache</span><span class="z-keyword z-operator">[j++];</span></span>
<span class=giallo-l><span class="z-keyword z-control">                else</span><span class=z-variable> list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator">[p++] =</span><span class=z-variable> cache</span><span class="z-keyword z-operator">[i++];</span></span>
<span class=giallo-l><span>            }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-control">            while</span><span class="z-keyword z-operator"> (i &lt; mid)</span><span class=z-variable> list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator">[p++] =</span><span class=z-variable> cache</span><span class="z-keyword z-operator">[i++];</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-control">            while</span><span class="z-keyword z-operator"> (j &lt; end)</span><span class=z-variable> list</span><span>-></span><span class=z-variable>buf</span><span class="z-keyword z-operator">[p++] =</span><span class=z-variable> cache</span><span class="z-keyword z-operator">[j++];</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> _merge</span><span class="z-keyword z-operator">(ElemType *</span><span class=z-variable>buf</span><span class="z-keyword z-operator">, ElemType *</span><span class=z-variable>cache</span><span>,</span><span class="z-storage z-type"> int</span><span class=z-variable> start</span><span>,</span><span class="z-storage z-type"> int</span><span class=z-variable> mid</span><span>,</span><span class="z-storage z-type"> int</span><span class=z-variable> end</span><span>, cmp </span><span class=z-variable>cmp</span><span>)；</span></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> _merge_sort</span><span class="z-keyword z-operator">(ElemType *</span><span class=z-variable>buf</span><span class="z-keyword z-operator">, ElemType *</span><span class=z-variable>cache</span><span>,</span><span class="z-storage z-type"> int</span><span class=z-variable> start</span><span>,</span><span class="z-storage z-type"> int</span><span class=z-variable> end</span><span>, cmp </span><span class=z-variable>cmp</span><span>)；</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>// 递归</span></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> merge_sort_rec</span><span class="z-keyword z-operator">(SqList *</span><span class=z-variable>list</span><span>, cmp </span><span class=z-variable>cmp</span><span>){</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    ElemType *cache = (ElemType*)</span><span class="z-entity z-name z-function">malloc</span><span>(</span><span class="z-keyword z-operator z-sizeof">sizeof</span><span class="z-keyword z-operator">(ElemType) *</span><span class=z-variable> list</span><span>-></span><span class=z-variable>len</span><span>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-entity z-name z-function">    _merge_sort</span><span>(</span><span class=z-variable>list</span><span>-></span><span class=z-variable>buf</span><span>, cache,</span><span class="z-constant z-numeric"> 0</span><span>,</span><span class=z-variable> list</span><span>-></span><span class=z-variable>len</span><span>, cmp);</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> _merge</span><span class="z-keyword z-operator">(ElemType *</span><span class=z-variable>buf</span><span class="z-keyword z-operator">, ElemType *</span><span class=z-variable>cache</span><span>,</span><span class="z-storage z-type"> int</span><span class=z-variable> start</span><span>,</span><span class="z-storage z-type"> int</span><span class=z-variable> mid</span><span>,</span><span class="z-storage z-type"> int</span><span class=z-variable> end</span><span>, cmp </span><span class=z-variable>cmp</span><span>) {</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class="z-keyword z-operator"> i = start, p = start, j = mid;</span></span>
<span class=giallo-l><span class="z-keyword z-control">    while</span><span class="z-keyword z-operator"> (i &lt; mid && j &lt; end) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">        if</span><span> (</span><span class="z-entity z-name z-function">compare</span><span class="z-keyword z-operator">(cache + i, cache + j) ></span><span class="z-constant z-numeric"> 0</span><span>)</span><span class=z-variable> buf</span><span class="z-keyword z-operator">[p++] =</span><span class=z-variable> cache</span><span class="z-keyword z-operator">[j++];</span></span>
<span class=giallo-l><span class="z-keyword z-control">        else</span><span class=z-variable> buf</span><span class="z-keyword z-operator">[p++] =</span><span class=z-variable> cache</span><span class="z-keyword z-operator">[i++];</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-control">    while</span><span class="z-keyword z-operator"> (i &lt; mid)</span><span class=z-variable> buf</span><span class="z-keyword z-operator">[p++] =</span><span class=z-variable> cache</span><span class="z-keyword z-operator">[i++];</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-control">    while</span><span class="z-keyword z-operator"> (j &lt; end)</span><span class=z-variable> buf</span><span class="z-keyword z-operator">[p++] =</span><span class=z-variable> cache</span><span class="z-keyword z-operator">[j++];</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> _merge_sort</span><span class="z-keyword z-operator">(ElemType *</span><span class=z-variable>buf</span><span class="z-keyword z-operator">, ElemType *</span><span class=z-variable>cache</span><span>,</span><span class="z-storage z-type"> int</span><span class=z-variable> start</span><span>,</span><span class="z-storage z-type"> int</span><span class=z-variable> end</span><span>, cmp </span><span class=z-variable>cmp</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">    if</span><span class="z-keyword z-operator"> (end - start &lt;=</span><span class="z-constant z-numeric"> 1</span><span>)</span><span class="z-keyword z-control"> return</span><span>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class="z-keyword z-operator"> mid = (start + end) >></span><span class="z-constant z-numeric"> 1</span><span>;</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span class=z-comment>    // divide O(log2n)</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    _merge_sort</span><span>(buf, cache, start, mid, cmp);</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    _merge_sort</span><span>(buf, cache, mid, end, cmp);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-entity z-name z-function">    memmove</span><span class="z-keyword z-operator">(cache + start, buf + start,</span><span class="z-keyword z-operator z-sizeof"> sizeof</span><span class="z-keyword z-operator">(ElemType) * (end - start));</span></span>
<span class=giallo-l><span class=z-comment>    // merge O(n)</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    _merge</span><span>(buf, cache, start, mid, end, cmp);</span></span>
<span class=giallo-l><span>}</span></span></code></pre><h2 id=ji-shu-pai-xu>基数排序</h2><p>一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。基于分配和收集。<ol><li>分类：基数排序<li>适用范围：n较大，关键字d较小<li>适用数据结构：适用于链表<li>时间复杂度： <ul><li>平均：O($nd$)：分治:O($\log_2{n}$),合并O($n$)<li>最好：O($nd$)：<li>最坏：O($nd$)：</ul><li>空间复杂度：O($r$)：基<li>稳定性：稳定</ol><h2 id=zong-jie>总结</h2><p>勘误：下图快速排序空间复杂度为O($log_2{n}$) <img alt src=/asset/sort.png></section></article></main><div id=button-container><div id=toc-floating-container><input class=toggle id=toc-toggle type=checkbox><label title="Toggle Table of Contents" class=button for=toc-toggle id=toc-button><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M414.82-193.094q-18.044 0-30.497-12.32-12.453-12.319-12.453-30.036t12.453-30.086q12.453-12.37 30.497-12.37h392.767q17.237 0 29.927 12.487 12.69 12.486 12.69 30.203 0 17.716-12.69 29.919t-29.927 12.203H414.82Zm0-244.833q-18.044 0-30.497-12.487Q371.87-462.9 371.87-480.45t12.453-29.92q12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.511 12.69 12.512 12.69 29.845 0 17.716-12.69 30.086-12.69 12.37-29.927 12.37H414.82Zm0-245.167q-18.044 0-30.497-12.32t-12.453-30.037q0-17.716 12.453-30.086 12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.486 12.69 12.487 12.69 30.203 0 17.717-12.69 29.92-12.69 12.203-29.927 12.203H414.82ZM189.379-156.681q-32.652 0-55.878-22.829t-23.226-55.731q0-32.549 23.15-55.647 23.151-23.097 55.95-23.097 32.799 0 55.313 23.484 22.515 23.484 22.515 56.246 0 32.212-22.861 54.893-22.861 22.681-54.963 22.681Zm0-245.167q-32.652 0-55.878-23.134-23.226-23.135-23.226-55.623 0-32.487 23.467-55.517t56.12-23.03q32.102 0 54.721 23.288 22.62 23.288 22.62 55.775 0 32.488-22.861 55.364-22.861 22.877-54.963 22.877Zm-.82-244.833q-32.224 0-55.254-23.288-23.03-23.289-23.03-55.623 0-32.333 23.271-55.364 23.272-23.03 55.495-23.03 32.224 0 55.193 23.288 22.969 23.289 22.969 55.622 0 32.334-23.21 55.364-23.21 23.031-55.434 23.031Z"/></svg></label><div class=toc-content><div class=toc-container><ul><li><a href=https://bieyuanxi.github.io/blog/sort/#nei-bu-pai-xu>内部排序</a> <ul><li><a href=https://bieyuanxi.github.io/blog/sort/#fen-lei>分类</a><li><a href=https://bieyuanxi.github.io/blog/sort/#cha-ru-pai-xu>插入排序</a> <ul><li><a href=https://bieyuanxi.github.io/blog/sort/#zhi-jie-cha-ru-pai-xu>直接插入排序</a></ul><li><a href=https://bieyuanxi.github.io/blog/sort/#xi-er-pai-xu-suo-xiao-zeng-liang-pai-xu>希尔排序/缩小增量排序</a><li><a href=https://bieyuanxi.github.io/blog/sort/#mou-pao-pai-xu>冒泡排序</a><li><a href=https://bieyuanxi.github.io/blog/sort/#kuai-su-pai-xu>快速排序</a><li><a href=https://bieyuanxi.github.io/blog/sort/#jian-dan-xuan-ze-pai-xu>(简单)选择排序</a><li><a href=https://bieyuanxi.github.io/blog/sort/#dui-pai-xu>堆排序</a><li><a href=https://bieyuanxi.github.io/blog/sort/#gui-bing-pai-xu>归并排序</a><li><a href=https://bieyuanxi.github.io/blog/sort/#ji-shu-pai-xu>基数排序</a><li><a href=https://bieyuanxi.github.io/blog/sort/#zong-jie>总结</a></ul></ul></div></div></div><a title="Go to the top of the page" class=no-hover-padding href=# id=top-button> <svg viewbox="0 0 20 20" fill=currentColor><path d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z"/></svg> </a></div><span class=hidden id=copy-success> Copied! </span><span class=hidden id=copy-init> Copy code to clipboard </span><script defer src=https://bieyuanxi.github.io/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" href=https://bieyuanxi.github.io/atom.xml> <img alt=feed loading=lazy src=https://bieyuanxi.github.io/social_icons/rss.svg title=feed> </a></ul></nav><nav class=nav-navs></nav><div class=credits><small> Powered by <a href=https://www.getzola.org>Zola</a> & <a href=https://github.com/welpo/tabi>tabi</a> </small></div></section><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><h1 class=visually-hidden id=modalTitle>Search</h1><div id=modal-content><div id=searchBar><div aria-hidden=true class=search-icon><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search… role=combobox spellcheck=false><div class="close-icon interactive-icon" title="Clear search" id=clear-search role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></div></div><div id=results-container><div id=results-info><span id=zero_results> No results</span><span id=one_results> $NUMBER result</span><span id=many_results> $NUMBER results</span><span id=two_results> $NUMBER results</span><span id=few_results> $NUMBER results</span></div><div id=results role=listbox></div></div></div></div></footer>