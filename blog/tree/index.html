<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="default-src 'self';font-src 'self' data:;img-src 'self' https://* data:;media-src 'self';style-src 'self';frame-src player.vimeo.com https://www.youtube-nocookie.com;connect-src 'self';script-src 'self' 'self'" http-equiv=Content-Security-Policy><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://bieyuanxi.github.io name=base><title>
Terra's Blog • 树与二叉树</title><link title="Terra's Blog - Atom Feed" href=https://bieyuanxi.github.io/atom.xml rel=alternate type=application/atom+xml><link href="https://bieyuanxi.github.io/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://bieyuanxi.github.io/main.css?h=045c365e19a4d50a64bb" rel=stylesheet><meta content="light dark" name=color-scheme><meta content=YOUR_SITE_DESCRIPTION name=description><meta content=YOUR_SITE_DESCRIPTION property=og:description><meta content=树与二叉树 property=og:title><meta content=article property=og:type><meta content=en_GB property=og:locale><meta content=https://bieyuanxi.github.io/blog/tree/ property=og:url><meta content="Terra's Blog" property=og:site_name><noscript><link href=https://bieyuanxi.github.io/no_js.css rel=stylesheet></noscript><script src=https://bieyuanxi.github.io/js/initializeTheme.min.js></script><script defer src=https://bieyuanxi.github.io/js/themeSwitcher.min.js></script><script src="https://bieyuanxi.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><a href=#main-content id=skip-link>Skip to content</a><header><nav class=navbar><div class=nav-title><a class=home-title href=https://bieyuanxi.github.io/>Terra's Blog</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://bieyuanxi.github.io/blog/>blog </a><li><a class="nav-links no-hover-padding" href=https://bieyuanxi.github.io/archive/>archive </a><li><a class="nav-links no-hover-padding" href=https://bieyuanxi.github.io/tags/>tags </a><li><a class="nav-links no-hover-padding" href=https://bieyuanxi.github.io/projects/>projects </a><li class=menu-icons-container><ul class=menu-icons-group><li class="js menu-icon"><div aria-label="Click or press $SHORTCUT to open search" class="search-icon interactive-icon" title="Click or press $SHORTCUT to open search" id=search-button role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><li class="theme-switcher-wrapper js"><div aria-label="Toggle dark mode" title="Toggle dark/light mode" aria-pressed=false class=theme-switcher role=button tabindex=0></div><div aria-label="Reset mode to default" class="theme-resetter arrow" title="Reset mode to default" aria-hidden=true role=button tabindex=0></div></ul></ul></div></nav></header><div class=content id=main-content><main><article class=h-entry><h1 class="p-name article-title">树与二叉树</h1><a class="u-url u-uid" href=https://bieyuanxi.github.io/blog/tree/></a><ul class=meta><span class="hidden p-author h-card"> <a class=u-url href=https://bieyuanxi.github.io rel=author title=Terra>Terra</a> </span><li><time class=dt-published datetime=2023-11-23>23rd Nov 2023</time><li title="2375 words"><span aria-hidden=true class=separator>•</span>12 min read<li class=tag><span aria-hidden=true class=separator>•</span>Tags: <li class=tag><a class=p-category href=https://bieyuanxi.github.io/tags/shu/>树</a></ul><section class="e-content body"><h1 id=shu-yu-er-cha-shu>树与二叉树</h1><p>树是n个结点的有限集。在任意一棵非空树中：<ol><li>有且只有一个被称为根的结点<li>当n>1时，其余结点可分为m个互不相交的有限集，其中每一个集合都是一棵树，被称为根的子树。</ol><h2 id=ji-ben-gai-nian>基本概念</h2><ol><li>树的结点：包含一个数据元素及若干指向其子树的分支。<li>结点的度：结点拥有的子树的个数。<li>树的度：树内结点的度的最大值。<li>叶子结点：度为0的结点。<li>孩子结点：结点的子树的根，即该结点的直接后继。<li>双亲结点：该结点的直接前驱。<li>兄弟结点：同一个双亲的孩子之间互称兄弟结点。<li>祖先结点：从根到该结点的所经分支上的所有结点。<li>子孙结点：以该节点为根的子树中的任意结点称为该结点的子孙。<li>结点的层次：从开始定义，根为第一层，根的直接后继为第二层，以此类推。<li>树的高度/深度：树中结点的最大层次。<li>有序树：如果将树中各子树看成从左到右是有次序的（即不能互换），称该树为有序树，否则称为无序树。<li>森林：森林是m棵<strong>互不相交的树</strong>的集合。</ol><h2 id=er-cha-shu>二叉树</h2><p>二叉树每个结点最多只有两棵子树（结点度&lt;=2），且有左右之分，次序不能颠倒。<p>根据访问根结点(D)、左孩子(L)、右孩子(R)的不同顺序分为：先序遍历(DLR)、中序遍历(LDR)、后续遍历(LRD)；分别得到前缀表示（波兰式）、中缀表示、后缀表示（逆波兰式）。<ol><li>满二叉树：深度为k且有2^k-1个结点的树。<li>完全二叉树：深度为k有n个结点的二叉树，当且仅当其每一个结点都与深度为k的满二叉树中编号从1到n的结点一一对应时，称为完全二叉树。</ol><h2 id=er-cha-shu-de-xing-zhi>二叉树的性质</h2><ol><li>二叉树的第i层上最多有2^(i-1)个结点。<li>深度为k的二叉树最多有2^k-1个结点。<li>设二叉树的叶子结点、度为1的结点、度为2的结点个数分别为n0,n1,n2，则有公式n0=n2+1。<li>具有n个结点的完全二叉树的深度为[log2(n)] + 1 (这里取下限)<li>对具有n个结点的完全二叉树，按层序编号，则对任一结点i,有 <ol><li>若i=1,则i无双亲结点；若i>1,则i的双亲结点为i/2；<li>若2 * i>n,则i没有左孩子；否则左孩子结点为2 * i;<li>若2 * i+1>n，则i没有右孩子;否则右孩子结点为2 * i + 1;</ol></ol><h2 id=er-cha-shu-de-cun-chu-jie-gou>二叉树的存储结构</h2><h3 id=shun-xu-cun-chu-jie-gou>顺序存储结构</h3><p>用一组地址连续的存储单元依次自上而下，自左至右存储完全二叉树上的结点元素，仅适用于完全二叉树。<pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-control">#define</span><span class="z-entity z-name z-function z-preprocessor"> MAX_TREE_SIZE</span><span class="z-constant z-numeric"> 128</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef int</span><span> TElemType;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-keyword>typedef</span><span> TElemType </span><span class=z-variable>sqBTree</span><span>[MAX_TREE_SIZE];</span></span></code></pre><h3 id=lian-shi-cun-chu-jie-gou>链式存储结构</h3><p>数据域+左右指针，二叉链表、三叉链表<pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class=z-comment>//二叉链表</span></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> _BNode {</span></span>
<span class=giallo-l><span class="z-storage z-type">    struct</span><span class="z-keyword z-operator"> _BNode *lchild, *rchild;</span></span>
<span class=giallo-l><span>    TElemType data;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">} BNode, *LinkBtree;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>//三叉链表</span></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> _BDNode {</span></span>
<span class=giallo-l><span class="z-storage z-type">    struct</span><span class="z-keyword z-operator"> _BDNode *lchild, *rchild;</span></span>
<span class=giallo-l><span class="z-storage z-type">    struct</span><span class="z-keyword z-operator"> _BDNode *parent;</span></span>
<span class=giallo-l><span>    TElemType data;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">} BDNode, *DLinkBtree;</span></span></code></pre><h2 id=chuang-jian-er-cha-shu>创建二叉树</h2><ul><li>已知前序表示和中序表示，可以唯一确定一棵二叉树；<li>已知后续表示和中序表示，可以唯一确定一棵二叉树；<li>已知前序表示和后续表示，不能唯一确定一棵二叉树；</ul><h3 id=xian-xu-xu-lie-di-gui-chuang-jian>先序序列递归创建</h3><p>以先序遍历的方式一个一个输入结点（空结点以’#’代替）<pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-operator">BNode*</span><span class="z-entity z-name z-function"> _make_node</span><span>() {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    BNode *t = (BNode*)</span><span class="z-entity z-name z-function">malloc</span><span>(</span><span class="z-keyword z-operator z-sizeof">sizeof</span><span>(BNode));</span></span>
<span class=giallo-l><span class=z-variable>    t</span><span>-></span><span class=z-variable>data</span><span class="z-keyword z-operator"> =</span><span class="z-constant z-numeric"> 0</span><span>;</span></span>
<span class=giallo-l><span class=z-variable>    t</span><span>-></span><span class=z-variable>lchild</span><span class="z-keyword z-operator"> =</span><span class="z-constant z-language"> NULL</span><span>;</span></span>
<span class=giallo-l><span class=z-variable>    t</span><span>-></span><span class=z-variable>rchild</span><span class="z-keyword z-operator"> =</span><span class="z-constant z-language"> NULL</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-control">    return</span><span> t;</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> CreateLinkBTreeRecursive</span><span class="z-keyword z-operator">(LinkBtree *</span><span class=z-variable>btree</span><span>) {</span></span>
<span class=giallo-l><span class="z-storage z-type">    char</span><span class="z-keyword z-operator"> in =</span><span class="z-entity z-name z-function"> getchar</span><span>();</span></span>
<span class=giallo-l><span class="z-keyword z-control">    if</span><span class="z-keyword z-operator">(in ==</span><span class=z-string> '#'</span><span class="z-keyword z-operator">) {*btree =</span><span class="z-constant z-language"> NULL</span><span>;</span><span class="z-keyword z-control"> return</span><span>;}</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    BNode *node =</span><span class="z-entity z-name z-function"> _make_node</span><span>();</span></span>
<span class=giallo-l><span class="z-keyword z-control">    if</span><span class="z-keyword z-operator">(!node)</span><span class="z-entity z-name z-function"> exit</span><span>(</span><span class="z-constant z-numeric">1</span><span>);</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span class=z-variable>    node</span><span>-></span><span class=z-variable>data</span><span class="z-keyword z-operator"> = in;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    *btree = node;</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    CreateLinkBTreeRecursive</span><span class="z-keyword z-operator">(&</span><span class=z-variable>node</span><span>-></span><span class=z-variable>lchild</span><span>);</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    CreateLinkBTreeRecursive</span><span class="z-keyword z-operator">(&</span><span class=z-variable>node</span><span>-></span><span class=z-variable>rchild</span><span>);</span></span>
<span class=giallo-l><span>}</span></span></code></pre><h3 id=xian-xu-xu-lie-zhong-xu-xu-lie>先序序列+中序序列</h3><p>给出先序序列和中序序列，得到唯一二叉树 例子：<pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class=z-comment>//先序：ABCDEF</span></span>
<span class=giallo-l><span class=z-comment>//中序：CBAEDF</span></span>
<span class=giallo-l><span class=z-comment>// 先序是DLR,所以A是根节点；中序是LDR,所以A左边都是A的左子孙，A右边的都是A的右子孙；递归地处理即可。</span></span></code></pre><h3 id=hou-xu-xu-lie-zhong-xu-xu-lie>后序序列+中序序列</h3><p>给出后序序列和中序序列，得到唯一二叉树<h2 id=bian-li-er-cha-shu>遍历二叉树</h2><p>时间复杂度：O(n)；<p>空间复杂度：树的深度，最坏情况为O(n)；<h3 id=xian-xu-bian-li>先序遍历</h3><ul><li>若二叉树为NULL,空操作，否则： <ol><li>访问根结点；<li>先序遍历左子树；<li>先序遍历右子树；</ol></ul><pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class=z-comment>//递归</span></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> PreOrderTraverse</span><span>(LinkBtree </span><span class=z-variable>btree</span><span>, visit </span><span class=z-variable>callback</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">    if</span><span class="z-keyword z-operator"> (!btree)</span><span class="z-keyword z-control"> return</span><span>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-entity z-name z-function">    callback</span><span>(</span><span class=z-variable>btree</span><span>-></span><span class=z-variable>data</span><span>);</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    PreOrderTraverse</span><span>(</span><span class=z-variable>btree</span><span>-></span><span class=z-variable>lchild</span><span>, callback);</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    PreOrderTraverse</span><span>(</span><span class=z-variable>btree</span><span>-></span><span class=z-variable>rchild</span><span>, callback);</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>//非递归</span></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> PreOrderTraverseNonRec</span><span>(LinkBtree </span><span class=z-variable>btree</span><span>, visit </span><span class=z-variable>callback</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    BNode*</span><span class=z-variable> stack</span><span>[</span><span class="z-constant z-numeric">128</span><span>];</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class="z-keyword z-operator"> top =</span><span class="z-constant z-numeric"> 0</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    BNode *p =</span><span class="z-constant z-language"> NULL</span><span>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-operator">    p = btree;</span></span>
<span class=giallo-l><span class="z-keyword z-control">    while</span><span class="z-keyword z-operator"> (top ></span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator"> || p) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">        if</span><span> (p) {</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">            callback</span><span>(</span><span class=z-variable>p</span><span>-></span><span class=z-variable>data</span><span>);</span><span class=z-comment>   //pre-order</span></span>
<span class=giallo-l><span class=z-variable>            stack</span><span class="z-keyword z-operator">[top++] = p;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">            p =</span><span class=z-variable> p</span><span>-></span><span class=z-variable>lchild</span><span>;</span></span>
<span class=giallo-l><span>        }</span><span class="z-keyword z-control"> else</span><span> {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">            p =</span><span class=z-variable> stack</span><span class="z-keyword z-operator">[--top];</span></span>
<span class=giallo-l><span class="z-keyword z-operator">            p =</span><span class=z-variable> p</span><span>-></span><span class=z-variable>rchild</span><span>;</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span></code></pre><h3 id=zhong-xu-bian-li>中序遍历</h3><pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class=z-comment>//递归</span></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> InOrderTraverse</span><span>(LinkBtree </span><span class=z-variable>btree</span><span>, visit </span><span class=z-variable>callback</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">    if</span><span class="z-keyword z-operator"> (!btree)</span><span class="z-keyword z-control"> return</span><span>;</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    InOrderTraverse</span><span>(</span><span class=z-variable>btree</span><span>-></span><span class=z-variable>lchild</span><span>, callback);</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    callback</span><span>(</span><span class=z-variable>btree</span><span>-></span><span class=z-variable>data</span><span>);</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    InOrderTraverse</span><span>(</span><span class=z-variable>btree</span><span>-></span><span class=z-variable>rchild</span><span>, callback);</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>//非递归</span></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> PreOrderTraverseNonRec</span><span>(LinkBtree </span><span class=z-variable>btree</span><span>, visit </span><span class=z-variable>callback</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    BNode*</span><span class=z-variable> stack</span><span>[</span><span class="z-constant z-numeric">128</span><span>];</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class="z-keyword z-operator"> top =</span><span class="z-constant z-numeric"> 0</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    BNode *p =</span><span class="z-constant z-language"> NULL</span><span>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-operator">    p = btree;</span></span>
<span class=giallo-l><span class="z-keyword z-control">    while</span><span class="z-keyword z-operator"> (top ></span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator"> || p) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">        if</span><span> (p) {</span></span>
<span class=giallo-l><span class=z-variable>            stack</span><span class="z-keyword z-operator">[top++] = p;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">            p =</span><span class=z-variable> p</span><span>-></span><span class=z-variable>lchild</span><span>;</span></span>
<span class=giallo-l><span>        }</span><span class="z-keyword z-control"> else</span><span> {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">            p =</span><span class=z-variable> stack</span><span class="z-keyword z-operator">[--top];</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">            callback</span><span>(</span><span class=z-variable>p</span><span>-></span><span class=z-variable>data</span><span>);</span><span class=z-comment>   //in-order</span></span>
<span class=giallo-l><span class="z-keyword z-operator">            p =</span><span class=z-variable> p</span><span>-></span><span class=z-variable>rchild</span><span>;</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span></code></pre><h3 id=hou-xu-bian-li>后序遍历</h3><pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class=z-comment>//递归</span></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> PostOrderTraverse</span><span>(LinkBtree </span><span class=z-variable>btree</span><span>, visit </span><span class=z-variable>callback</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">    if</span><span class="z-keyword z-operator"> (!btree)</span><span class="z-keyword z-control"> return</span><span>;</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    PostOrderTraverse</span><span>(</span><span class=z-variable>btree</span><span>-></span><span class=z-variable>lchild</span><span>, callback);</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    PostOrderTraverse</span><span>(</span><span class=z-variable>btree</span><span>-></span><span class=z-variable>rchild</span><span>, callback);</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    callback</span><span>(</span><span class=z-variable>btree</span><span>-></span><span class=z-variable>data</span><span>);</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>//非递归</span></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> PostOrderTraverseNonRec</span><span>(LinkBtree </span><span class=z-variable>btree</span><span>, visit </span><span class=z-variable>callback</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    BNode*</span><span class=z-variable> stack</span><span>[</span><span class="z-constant z-numeric">128</span><span>];</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class="z-keyword z-operator"> top =</span><span class="z-constant z-numeric"> 0</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    BNode *p =</span><span class="z-constant z-language"> NULL</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    BNode *pre =</span><span class="z-constant z-language"> NULL</span><span>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-operator">    p = btree;</span></span>
<span class=giallo-l><span class="z-keyword z-control">    while</span><span class="z-keyword z-operator"> (top ></span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator"> || p) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">        if</span><span> (p) {</span></span>
<span class=giallo-l><span class=z-variable>            stack</span><span class="z-keyword z-operator">[top++] = p;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">            p =</span><span class=z-variable> p</span><span>-></span><span class=z-variable>lchild</span><span>;</span></span>
<span class=giallo-l><span>        }</span><span class="z-keyword z-control"> else</span><span> {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">            p =</span><span class=z-variable> stack</span><span class="z-keyword z-operator">[top -</span><span class="z-constant z-numeric"> 1</span><span>];</span></span>
<span class=giallo-l><span class="z-keyword z-control">            if</span><span class="z-keyword z-operator"> (!</span><span class=z-variable>p</span><span>-></span><span class=z-variable>rchild</span><span class="z-keyword z-operator"> ||</span><span class=z-variable> p</span><span>-></span><span class=z-variable>rchild</span><span class="z-keyword z-operator"> == pre) {</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">                callback</span><span>(</span><span class=z-variable>p</span><span>-></span><span class=z-variable>data</span><span>);</span></span>
<span class=giallo-l><span class="z-keyword z-operator">                pre = p;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">                top--;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">                p =</span><span class="z-constant z-language"> NULL</span><span>;</span></span>
<span class=giallo-l><span>            }</span><span class="z-keyword z-control"> else</span><span> {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">                p =</span><span class=z-variable> p</span><span>-></span><span class=z-variable>rchild</span><span>;</span></span>
<span class=giallo-l><span>            }</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span></code></pre><h2 id=xian-suo-er-cha-shu>线索二叉树</h2><p>时间复杂度：O(n)<p>若所用二叉树需要经常遍历或查找结点在遍历所得线性序列中的前驱和后继，应采用线索链表作存储结构。<p>将二叉树按照某种遍历方式储存起来（线索化），使其能像二叉链表一样知道一个结点便可遍历其余结点，提高效率。<p>在有n个结点的二叉链表中必定有n+1个空链域，可以利用这些空链域存放结点的前驱和后继的信息。<pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-operator">+--------+-------+-------+-------+-------+</span></span>
<span class=giallo-l><span class="z-keyword z-operator">|lchild  |Ltag   |data   |RTag   |rchild |</span></span>
<span class=giallo-l><span class="z-keyword z-operator">+--------+-------+-------+-------+-------+</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-operator">LTag =</span><span class="z-constant z-numeric"> 0</span><span> (lchild指示结点的左孩子)</span></span>
<span class=giallo-l><span class="z-keyword z-operator">     =</span><span class="z-constant z-numeric"> 1</span><span> (lchild指示结点的前驱)</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-operator">RTag =</span><span class="z-constant z-numeric"> 0</span><span> (lchild指示结点的右孩子)</span></span>
<span class=giallo-l><span class="z-keyword z-operator">     =</span><span class="z-constant z-numeric"> 1</span><span> (lchild指示结点的后继)</span></span></code></pre><p>以这种结点结构构成的二叉链表，叫做<strong>线索链表</strong>。 其中指向结点前驱和后继的指针叫做<strong>线索</strong>。 加上线索的二叉树称之为<strong>线索二叉树</strong>。 对二叉树以某种次序遍历使其变为线索二叉树的过程叫做<strong>线索化</strong>。<pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-storage z-type">typedef enum</span><span> PointerTag {Link, Thread};</span><span class=z-comment> //Link指针，Thread线索</span></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> BiThrNode {</span></span>
<span class=giallo-l><span>    TElemType data;</span></span>
<span class=giallo-l><span class="z-storage z-type">    struct</span><span class="z-keyword z-operator"> BiThrNode *lchild, *rchild;</span></span>
<span class=giallo-l><span>    PointerTag ltag, rtag;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">} BiThrNode *BiThrTree;</span></span></code></pre><h3 id=zhong-xu-xian-suo-shu>中序线索树</h3><ol><li>树中所有叶子结点的右链是线索，右链指示结点的后继； 1.结点的后继是遍历其右子树时访问的第一个结点，即右子树中最左下的结点；<li>结点的前驱是遍历左子树时最后访问的一个结点，即左子树中最右下的结点；</ol><pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class=z-comment>//在二叉树的线索链表上添加一个头结点，令其lchild域的指针指向二叉树的根节点，其rchild域的指针指向中序遍历时访问的最后一个结点。</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> InOrderThreading</span><span class="z-keyword z-operator">(BiThrTree *</span><span class=z-variable>Thrt</span><span>, BiThrTree </span><span class=z-variable>T</span><span>) {</span></span>
<span class=giallo-l><span class=z-comment>    //中序遍历二叉树T,并将其中序线索化，Thrt指向头结点</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    *Thrt = (BiThrTree)</span><span class="z-entity z-name z-function">malloc</span><span>(</span><span class="z-keyword z-operator z-sizeof">sizeof</span><span>(BiThrNode));</span></span>
<span class=giallo-l><span class="z-keyword z-control">    if</span><span class="z-keyword z-operator">(!*Thrt)</span><span class="z-entity z-name z-function"> exit</span><span>(</span><span class="z-constant z-numeric">1</span><span>);</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    (*Thrt)-></span><span class=z-variable>ltag</span><span class="z-keyword z-operator"> = Link;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    (*Thrt)-></span><span class=z-variable>rtag</span><span class="z-keyword z-operator"> = Thread;</span></span>
<span class=giallo-l><span class="z-keyword z-control">    if</span><span class="z-keyword z-operator">(!T) (*Thrt)-></span><span class=z-variable>lchild</span><span class="z-keyword z-operator"> = (*Thrt);</span></span>
<span class=giallo-l><span class="z-keyword z-control">    else</span><span> {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        (*Thrt)-></span><span class=z-variable>lchild</span><span class="z-keyword z-operator"> = T;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        pre = Thrt;</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">        InThreading</span><span>(T);</span></span>
<span class=giallo-l><span class=z-variable>        pre</span><span>-></span><span class=z-variable>rchild</span><span class="z-keyword z-operator"> = (*Thrt);</span></span>
<span class=giallo-l><span class=z-variable>        pre</span><span>-></span><span class=z-variable>rtag</span><span class="z-keyword z-operator"> = Thread;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        (*Thrt)-></span><span class=z-variable>rchild</span><span class="z-keyword z-operator"> = pre;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> InThreading</span><span>(BiThrTree </span><span class=z-variable>p</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">    if</span><span>(p) {</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">        InThreading</span><span>(</span><span class=z-variable>p</span><span>-></span><span class=z-variable>lchild</span><span>);</span></span>
<span class=giallo-l><span class="z-keyword z-control">        if</span><span class="z-keyword z-operator">(!</span><span class=z-variable>p</span><span>-></span><span class=z-variable>lchild</span><span>) {</span></span>
<span class=giallo-l><span class=z-variable>            p</span><span>-></span><span class=z-variable>ltag</span><span class="z-keyword z-operator"> = Thread;</span></span>
<span class=giallo-l><span class=z-variable>            p</span><span>-></span><span class=z-variable>lchild</span><span class="z-keyword z-operator"> = pre;</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span class="z-keyword z-control">        if</span><span class="z-keyword z-operator">(!</span><span class=z-variable>pre</span><span>-></span><span class=z-variable>rchild</span><span>) {</span></span>
<span class=giallo-l><span class=z-variable>            pre</span><span>-></span><span class=z-variable>rtag</span><span class="z-keyword z-operator"> = Thread;</span></span>
<span class=giallo-l><span class=z-variable>            pre</span><span>-></span><span class=z-variable>rchild</span><span class="z-keyword z-operator"> = p;</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        pre = p;</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">        InThreading</span><span>(</span><span class=z-variable>p</span><span>-></span><span class=z-variable>rchild</span><span>);</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> InOrderTranverse_Thr</span><span>(BiThrTree </span><span class=z-variable>tree</span><span>, visit </span><span class=z-variable>callback</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    p =</span><span class=z-variable> tree</span><span>-></span><span class=z-variable>lchild</span><span>;</span><span class=z-comment>   //令p指向根节点</span></span>
<span class=giallo-l><span class="z-keyword z-control">    while</span><span class="z-keyword z-operator"> (p != tree) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">        while</span><span> (</span><span class=z-variable>p</span><span>-></span><span class=z-variable>ltag</span><span class="z-keyword z-operator"> == Link) p =</span><span class=z-variable> p</span><span>-></span><span class=z-variable>lchild</span><span>;</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">        callback</span><span>(</span><span class=z-variable>p</span><span>-></span><span class=z-variable>data</span><span>);</span></span>
<span class=giallo-l><span class="z-keyword z-control">        while</span><span> (</span><span class=z-variable>p</span><span>-></span><span class=z-variable>rtag</span><span class="z-keyword z-operator"> == Thread &&</span><span class=z-variable> p</span><span>-></span><span class=z-variable>rchild</span><span class="z-keyword z-operator"> != tree) {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">            p =</span><span class=z-variable> p</span><span>-></span><span class=z-variable>rchild</span><span>;</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">            visit</span><span>(</span><span class=z-variable>p</span><span>-></span><span class=z-variable>data</span><span>);</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        p =</span><span class=z-variable> p</span><span>-></span><span class=z-variable>rchild</span><span>;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l></span></code></pre><h3 id=hou-xu-xian-suo-shu>后序线索树</h3><p>TODO<h2 id=er-cha-shu-de-qi-ta-cao-zuo>二叉树的其他操作</h2><h3 id=er-cha-shu-de-gao>二叉树的高</h3><p>递归地表示为max{左子树高度, 右子树高度} + 1。<h3 id=tong-ji-er-cha-shu-xie-zi-jie-dian-ge-shu>统计二叉树叶子结点个数</h3><p>遍历二叉树，callback访问结点是否是叶子结点，是的话总数加一。<h2 id=shu-he-sen-lin>树和森林</h2><h3 id=shu-de-cun-chu-jie-gou>树的存储结构</h3><ol><li>双亲表示法：易于表示双亲，遍历寻找孩子；<li>孩子表示法：易于表示孩子，遍历寻找双亲；<li><strong>孩子兄弟表示法/二叉树表示法</strong></ol><h4 id=shuang-qin-biao-shi-fa>双亲表示法</h4><p>以一组**连续空间（数组）**存储树的结点，同时在每个结点中附设一个指示器指示其双亲结点在链表中的位置。<p>优点：<ul><li>常量时间内求双亲</ul><p>缺点：<ul><li>求结点的孩子需要遍历表</ul><pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-control">#define</span><span class="z-entity z-name z-function z-preprocessor"> MAX_TREE_SIZE</span><span class="z-constant z-numeric"> 100</span></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> PTNode {</span></span>
<span class=giallo-l><span>    TElemType data;</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> parent;</span><span class=z-comment> //双亲位置index</span></span>
<span class=giallo-l><span>} PTNode;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> {</span></span>
<span class=giallo-l><span>    PTNode </span><span class=z-variable>nodes</span><span>[MAX_TREE_SIZE];</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> root_pos, num;</span><span class=z-comment>   //根的位置和结点数</span></span>
<span class=giallo-l><span>}</span></span></code></pre><h4 id=hai-zi-biao-shi-fa>孩子表示法</h4><p>使用<strong>多重链表</strong>，即每个结点有多个指针域，其中每个指针指向一棵子树的根节点。易于找到孩子，不易找到双亲。<p>纯链表可以采用两种结点格式：<ol><li>结点大小都相同，指针个数等于树的度。则在一棵有n个结点度为k的树中必有nk-(n-1)个空链域，缺点是浪费空间。<li>结点大小不确定，设置一个字段degree用来确定该结点的孩子个数，缺点是操作不方便。</ol><p>第三种方法是把每个结点的孩子结点排列起来，看成线性表，且以单链表作存储结构，则n个结点有n个孩子链表。n个头指针又组成一个线性表（采用顺序表）。<pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span>第三种：</span></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> CTNode {</span><span class=z-comment> //孩子结点</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> child;</span></span>
<span class=giallo-l><span class="z-storage z-type">    struct</span><span class="z-keyword z-operator"> CTNode *next;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">} *ChildPtr;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> {</span></span>
<span class=giallo-l><span>    TElemType data;</span></span>
<span class=giallo-l><span>    ChildPtr first_child;</span></span>
<span class=giallo-l><span>} CTBox;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> {</span></span>
<span class=giallo-l><span>    CTBox </span><span class=z-variable>nodes</span><span>[MAX_TREE_SIZE];</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> root_pos, num;</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span></code></pre><h4 id=hai-zi-xiong-di-biao-shi-fa>孩子兄弟表示法</h4><p>以二叉链表作树的存储结构。又称二叉树表示法/二叉链表表示法。<p><strong>链表中结点的两个链域分别指向该结点的第一个孩子结点和下一个兄弟结点。</strong><pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> CSNode {</span></span>
<span class=giallo-l><span>    ElemType data;</span></span>
<span class=giallo-l><span class="z-storage z-type">    struct</span><span class="z-keyword z-operator"> CSNode *first_child;</span><span class=z-comment> //第一个孩子</span></span>
<span class=giallo-l><span class="z-storage z-type">    struct</span><span class="z-keyword z-operator"> CSNode *nextsibling;</span><span class=z-comment> //第一个兄弟</span></span>
<span class=giallo-l><span class="z-keyword z-operator">} CSNode, *CSTree;</span></span></code></pre><ol><li>访问结点x的第i个结点：</ol><pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> index =</span><span class="z-constant z-numeric"> 1</span><span>;</span><span class=z-comment>  //若以0计数则修改为0</span></span>
<span class=giallo-l><span class="z-keyword z-operator">node = x->first_child;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-control">while</span><span class="z-keyword z-operator">(index &lt; i && node) {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    node =</span><span class=z-variable> node</span><span>-></span><span class=z-variable>nextsibling</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    index++;</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-control">if</span><span>(node) {</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    visit</span><span>(node);</span></span>
<span class=giallo-l><span>}</span><span class="z-keyword z-control">else</span><span>{</span></span>
<span class=giallo-l><span class="z-keyword z-control">    return</span><span>;</span></span>
<span class=giallo-l><span>}</span></span></code></pre><h3 id=sen-lin-yu-er-cha-shu-de-zhuan-huan>森林与二叉树的转换</h3><p>由于二叉树和树都可以用二叉链表作为存储结构，则以<strong>二叉链表</strong>作为媒介可以导出树与二叉树之间的对应关系。<h4 id=shu-zhuan-huan-wei-er-cha-shu>树转换为二叉树</h4><p>一棵树对应的二叉树，其右子树为空。<h4 id=er-cha-shu-zhuan-huan-wei-shu>二叉树转换为树</h4><h4 id=sen-lin-zhuan-huan-wei-er-cha-shu>森林转换为二叉树</h4><h4 id=er-cha-shu-zhuan-huan-wei-sen-lin>二叉树转换为森林</h4><h3 id=shu-he-sen-lin-de-bian-li>树和森林的遍历</h3><h4 id=shu-de-bian-li>树的遍历</h4><ol><li>先根（次序）遍历：二叉树的先序遍历<li>后根（次序）遍历：二叉树的中序遍历</ol><h4 id=sen-lin-de-bian-li>森林的遍历</h4><ol><li>先序遍历森林：二叉树的先序遍历<li>中序遍历森林：二叉树的中序遍历</ol><h2 id=shu-yu-deng-jia-wen-ti>树与等价问题</h2><p>TODO<h2 id=ha-fu-man-shu>哈夫曼树</h2><p>又称最优二叉树，是一类带权路径长度最短的树。<p>哈夫曼树中没有度为1的结点。则一棵有n个叶子结点的哈夫曼树一共有2<em>n-1个结点，可以存储在一个大小为2</em>n-1的一维数组中。<pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-storage z-type">typedef char</span><span class="z-keyword z-operator">** HuffmanCode;</span></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> {</span></span>
<span class=giallo-l><span class="z-storage z-type">    unsigned int</span><span> weight;</span></span>
<span class=giallo-l><span class="z-storage z-type">    unsigned int</span><span> parent, lchild, rchild;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">} HTNode, *HuffmanTree;</span></span></code></pre><h3 id=ji-ben-gai-nian-1>基本概念</h3><ol><li>路径：从树中一个结点到另一个结点之间的分支构成这两个结点之间的路径。<li>路径长度：路径上的分支数目。<li>树的路径长度：从树根到每一结点的路径长度之和。<li>结点的权：结点的权重？<li>结点的带权路径长度：从该结点到树根之间的路径长度与结点上的权的乘积。<li>树的带权路径长度：树中所有<strong>叶子结点</strong>的带权路径长度之和。记作：WPL=w1l1+w2l2+…<li>最优二叉树/哈夫曼树：使得有n个叶子结点的二叉树的带权路径长度最小的二叉树。</ol><h3 id=ha-fu-man-bian-ma>哈夫曼编码</h3><p>若要设计长短不等的编码，则必须是任一个字符的编码都不是另一个字符的编码的前缀，这种编码称作<strong>前缀编码</strong>。 可以利用二叉树来设计二进制的前缀编码。</section></article></main><div id=button-container><div id=toc-floating-container><input class=toggle id=toc-toggle type=checkbox><label title="Toggle Table of Contents" class=button for=toc-toggle id=toc-button><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M414.82-193.094q-18.044 0-30.497-12.32-12.453-12.319-12.453-30.036t12.453-30.086q12.453-12.37 30.497-12.37h392.767q17.237 0 29.927 12.487 12.69 12.486 12.69 30.203 0 17.716-12.69 29.919t-29.927 12.203H414.82Zm0-244.833q-18.044 0-30.497-12.487Q371.87-462.9 371.87-480.45t12.453-29.92q12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.511 12.69 12.512 12.69 29.845 0 17.716-12.69 30.086-12.69 12.37-29.927 12.37H414.82Zm0-245.167q-18.044 0-30.497-12.32t-12.453-30.037q0-17.716 12.453-30.086 12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.486 12.69 12.487 12.69 30.203 0 17.717-12.69 29.92-12.69 12.203-29.927 12.203H414.82ZM189.379-156.681q-32.652 0-55.878-22.829t-23.226-55.731q0-32.549 23.15-55.647 23.151-23.097 55.95-23.097 32.799 0 55.313 23.484 22.515 23.484 22.515 56.246 0 32.212-22.861 54.893-22.861 22.681-54.963 22.681Zm0-245.167q-32.652 0-55.878-23.134-23.226-23.135-23.226-55.623 0-32.487 23.467-55.517t56.12-23.03q32.102 0 54.721 23.288 22.62 23.288 22.62 55.775 0 32.488-22.861 55.364-22.861 22.877-54.963 22.877Zm-.82-244.833q-32.224 0-55.254-23.288-23.03-23.289-23.03-55.623 0-32.333 23.271-55.364 23.272-23.03 55.495-23.03 32.224 0 55.193 23.288 22.969 23.289 22.969 55.622 0 32.334-23.21 55.364-23.21 23.031-55.434 23.031Z"/></svg></label><div class=toc-content><div class=toc-container><ul><li><a href=https://bieyuanxi.github.io/blog/tree/#shu-yu-er-cha-shu>树与二叉树</a> <ul><li><a href=https://bieyuanxi.github.io/blog/tree/#ji-ben-gai-nian>基本概念</a><li><a href=https://bieyuanxi.github.io/blog/tree/#er-cha-shu>二叉树</a><li><a href=https://bieyuanxi.github.io/blog/tree/#er-cha-shu-de-xing-zhi>二叉树的性质</a><li><a href=https://bieyuanxi.github.io/blog/tree/#er-cha-shu-de-cun-chu-jie-gou>二叉树的存储结构</a> <ul><li><a href=https://bieyuanxi.github.io/blog/tree/#shun-xu-cun-chu-jie-gou>顺序存储结构</a><li><a href=https://bieyuanxi.github.io/blog/tree/#lian-shi-cun-chu-jie-gou>链式存储结构</a></ul><li><a href=https://bieyuanxi.github.io/blog/tree/#chuang-jian-er-cha-shu>创建二叉树</a> <ul><li><a href=https://bieyuanxi.github.io/blog/tree/#xian-xu-xu-lie-di-gui-chuang-jian>先序序列递归创建</a><li><a href=https://bieyuanxi.github.io/blog/tree/#xian-xu-xu-lie-zhong-xu-xu-lie>先序序列+中序序列</a><li><a href=https://bieyuanxi.github.io/blog/tree/#hou-xu-xu-lie-zhong-xu-xu-lie>后序序列+中序序列</a></ul><li><a href=https://bieyuanxi.github.io/blog/tree/#bian-li-er-cha-shu>遍历二叉树</a> <ul><li><a href=https://bieyuanxi.github.io/blog/tree/#xian-xu-bian-li>先序遍历</a><li><a href=https://bieyuanxi.github.io/blog/tree/#zhong-xu-bian-li>中序遍历</a><li><a href=https://bieyuanxi.github.io/blog/tree/#hou-xu-bian-li>后序遍历</a></ul><li><a href=https://bieyuanxi.github.io/blog/tree/#xian-suo-er-cha-shu>线索二叉树</a> <ul><li><a href=https://bieyuanxi.github.io/blog/tree/#zhong-xu-xian-suo-shu>中序线索树</a><li><a href=https://bieyuanxi.github.io/blog/tree/#hou-xu-xian-suo-shu>后序线索树</a></ul><li><a href=https://bieyuanxi.github.io/blog/tree/#er-cha-shu-de-qi-ta-cao-zuo>二叉树的其他操作</a> <ul><li><a href=https://bieyuanxi.github.io/blog/tree/#er-cha-shu-de-gao>二叉树的高</a><li><a href=https://bieyuanxi.github.io/blog/tree/#tong-ji-er-cha-shu-xie-zi-jie-dian-ge-shu>统计二叉树叶子结点个数</a></ul><li><a href=https://bieyuanxi.github.io/blog/tree/#shu-he-sen-lin>树和森林</a> <ul><li><a href=https://bieyuanxi.github.io/blog/tree/#shu-de-cun-chu-jie-gou>树的存储结构</a><li><a href=https://bieyuanxi.github.io/blog/tree/#sen-lin-yu-er-cha-shu-de-zhuan-huan>森林与二叉树的转换</a><li><a href=https://bieyuanxi.github.io/blog/tree/#shu-he-sen-lin-de-bian-li>树和森林的遍历</a></ul><li><a href=https://bieyuanxi.github.io/blog/tree/#shu-yu-deng-jia-wen-ti>树与等价问题</a><li><a href=https://bieyuanxi.github.io/blog/tree/#ha-fu-man-shu>哈夫曼树</a> <ul><li><a href=https://bieyuanxi.github.io/blog/tree/#ji-ben-gai-nian-1>基本概念</a><li><a href=https://bieyuanxi.github.io/blog/tree/#ha-fu-man-bian-ma>哈夫曼编码</a></ul></ul></ul></div></div></div><a title="Go to the top of the page" class=no-hover-padding href=# id=top-button> <svg viewbox="0 0 20 20" fill=currentColor><path d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z"/></svg> </a></div><span class=hidden id=copy-success> Copied! </span><span class=hidden id=copy-init> Copy code to clipboard </span><script defer src=https://bieyuanxi.github.io/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" href=https://bieyuanxi.github.io/atom.xml> <img alt=feed loading=lazy src=https://bieyuanxi.github.io/social_icons/rss.svg title=feed> </a></ul></nav><nav class=nav-navs></nav><div class=credits><small> Powered by <a href=https://www.getzola.org>Zola</a> & <a href=https://github.com/welpo/tabi>tabi</a> </small></div></section><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><h1 class=visually-hidden id=modalTitle>Search</h1><div id=modal-content><div id=searchBar><div aria-hidden=true class=search-icon><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search… role=combobox spellcheck=false><div class="close-icon interactive-icon" title="Clear search" id=clear-search role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></div></div><div id=results-container><div id=results-info><span id=zero_results> No results</span><span id=one_results> $NUMBER result</span><span id=many_results> $NUMBER results</span><span id=two_results> $NUMBER results</span><span id=few_results> $NUMBER results</span></div><div id=results role=listbox></div></div></div></div></footer>