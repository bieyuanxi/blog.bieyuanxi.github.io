<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="default-src 'self';font-src 'self' data:;img-src 'self' https://* data:;media-src 'self';style-src 'self';frame-src player.vimeo.com https://www.youtube-nocookie.com;connect-src 'self';script-src 'self' 'self'" http-equiv=Content-Security-Policy><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://bieyuanxi.github.io name=base><title>
Terra's Blog • 图</title><link title="Terra's Blog - Atom Feed" href=https://bieyuanxi.github.io/atom.xml rel=alternate type=application/atom+xml><link href="https://bieyuanxi.github.io/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://bieyuanxi.github.io/main.css?h=045c365e19a4d50a64bb" rel=stylesheet><meta content="light dark" name=color-scheme><meta content=YOUR_SITE_DESCRIPTION name=description><meta content=YOUR_SITE_DESCRIPTION property=og:description><meta content=图 property=og:title><meta content=article property=og:type><meta content=en_GB property=og:locale><meta content=https://bieyuanxi.github.io/blog/graph/ property=og:url><meta content="Terra's Blog" property=og:site_name><noscript><link href=https://bieyuanxi.github.io/no_js.css rel=stylesheet></noscript><script src=https://bieyuanxi.github.io/js/initializeTheme.min.js></script><script defer src=https://bieyuanxi.github.io/js/themeSwitcher.min.js></script><script src="https://bieyuanxi.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><a href=#main-content id=skip-link>Skip to content</a><header><nav class=navbar><div class=nav-title><a class=home-title href=https://bieyuanxi.github.io/>Terra's Blog</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://bieyuanxi.github.io/blog/>blog </a><li><a class="nav-links no-hover-padding" href=https://bieyuanxi.github.io/archive/>archive </a><li><a class="nav-links no-hover-padding" href=https://bieyuanxi.github.io/tags/>tags </a><li><a class="nav-links no-hover-padding" href=https://bieyuanxi.github.io/projects/>projects </a><li class=menu-icons-container><ul class=menu-icons-group><li class="js menu-icon"><div aria-label="Click or press $SHORTCUT to open search" class="search-icon interactive-icon" title="Click or press $SHORTCUT to open search" id=search-button role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><li class="theme-switcher-wrapper js"><div aria-label="Toggle dark mode" title="Toggle dark/light mode" aria-pressed=false class=theme-switcher role=button tabindex=0></div><div aria-label="Reset mode to default" class="theme-resetter arrow" title="Reset mode to default" aria-hidden=true role=button tabindex=0></div></ul></ul></div></nav></header><div class=content id=main-content><main><article class=h-entry><h1 class="p-name article-title">图</h1><a class="u-url u-uid" href=https://bieyuanxi.github.io/blog/graph/></a><ul class=meta><span class="hidden p-author h-card"> <a class=u-url href=https://bieyuanxi.github.io rel=author title=Terra>Terra</a> </span><li><time class=dt-published datetime=2023-11-22>22nd Nov 2023</time><li title="2709 words"><span aria-hidden=true class=separator>•</span>14 min read</ul><section class="e-content body"><h1 id=tu>图</h1><h2 id=ji-ben-gai-nian>基本概念</h2><ul><li><p>通用概念</p> <ol><li>顶点：图中的数据元素<li>权：与图的弧或者边有关的数<li>网：带权的图<li>子图<li>度</ol><li><p>无向图</p> <ol><li>边：无序对(u,v)<li>无向图：不区分弧头弧尾的图<li>完全图：有n*(n-1)/2条边的无向图<li>邻接点：无向图中有边关系的两个顶点互称邻接点<li>回路/环<li>简单路径：序列中顶点不重复出现的路径<li>连通：无向图，从顶点v到顶点u有路径<li>连通图：无向图中任意两个顶点是连通的<li>连通分量：无向图中的极大连通子图<li>极小连通子图：含有图中全部顶点，但只有n-1条边<li>生成树：一个连通图的生成树是一个极小连通子图</ol><li><p>有向图</p> <ol><li>弧&lt;u, v>，指从u到v的一条弧<li>弧尾：u<li>弧头：v<li>有向图：区分弧头弧尾的图<li>有向完全图：有n*(n-1)条边的有向图<li>有向无环图（DAG图）：无环的有向图<li>入度/出度<li>强连通图：有向图中任意两个顶点双向连通<li>强连通分量：有向图中的极大强连通子图<li>有向树：一个有向图中恰有一个顶点的入度为0,其余顶点的入度均为1<li>生成森林：一个有向图的生成森林由若干棵有向树组成，含有图中全部顶点，但只有足以构成若干棵不相交的有向树的弧。连通分量的生成树组成非连通图的生成森林。</ol></ul><h2 id=tu-de-cun-chu-jie-gou>图的存储结构</h2><p><strong>数组表示法（邻接矩阵）</strong>、<strong>邻接表</strong>、十字链表（有向图的链式存储结构）、邻接多重表（无向图的链式存储结构）<h3 id=lin-jie-ju-zhen>邻接矩阵</h3><p>用两个数组分别存储数据元素（顶点）信息和数据元素之间的关系（边或弧）的信息。<p>存储： n个结点空间，n^2个弧信息（无向图可以压缩至n*(n-1)/2）<p>适用于弧很多的情况，弧少时浪费空间<h4 id=jian-li-lin-jie-ju-zhen>建立邻接矩阵</h4><p>时间复杂度：O(n^2 + n*e) //n^2是初始化，n * e是因为对输入的每条边都要寻找对应的顶点<h4 id=du-de-ji-suan>度的计算</h4><ol><li>入度：矩阵第j列之和<li>出度：矩阵第i行之和</ol><pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-storage z-type">typedef enum</span><span> {DG, DN, UDG, UDN} GraphType;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> {</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> info;</span><span class=z-comment>   //顶点信息</span></span>
<span class=giallo-l><span>} Cell;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> {</span></span>
<span class=giallo-l><span>    GraphType type;</span></span>
<span class=giallo-l><span>    Cell </span><span class=z-variable>vexs</span><span>[MAX_VERTEX_NUM];</span><span class=z-comment>  //可以用指针</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class=z-variable> arcs</span><span>[MAX_VERTEX_NUM][MAX_VERTEX_NUM];</span><span class=z-comment>   //无向图存1、0,有向图存权</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> vex_num;</span></span>
<span class=giallo-l><span>} Graph;</span></span></code></pre><h3 id=lin-jie-biao>邻接表</h3><p>用数组存顶点信息，用链表存弧信息。<p>适用于边稀疏的情况。<p>缺点：<ul><li>对于无向图，一个边会对应两个弧结点，分别在两个链表中，操作不便（只用一个的话得遍历全部链表）。<li>对于有向图，不能同时快速得出入度和出度。（可以通过建立逆邻接表加速）</ul><h4 id=jian-li-lin-jie-biao>建立邻接表</h4><p>时间复杂度：O(n + e) //输入的顶点信息即为顶点编号 O(n * e) // 查找对应的顶点<h4 id=du-de-ji-suan-1>度的计算</h4><ol><li>入度：需要遍历每个结点的出度（可以通过建立逆邻接表加速）<li>出度：遍历该结点对应的链表皆可</ol><pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> {</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> info;</span><span class=z-comment>   //顶点信息</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    ArcNode *first_arc;</span><span class=z-comment> //第一条弧的指针</span></span>
<span class=giallo-l><span>} Cell;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> _ArcNode {</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> val;</span><span class=z-comment>   //权</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> adjvex;</span><span class=z-comment> //该弧指向的顶点</span></span>
<span class=giallo-l><span class="z-storage z-type">    struct</span><span class="z-keyword z-operator"> _ArcNode *next;</span></span>
<span class=giallo-l><span>} ArcNode;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> {</span></span>
<span class=giallo-l><span>    Cell vexs</span><span class="z-storage z-modifier">[]</span><span>;</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> vex_num;</span></span>
<span class=giallo-l><span>} Graph;</span></span></code></pre><h3 id=shi-zi-lian-biao>十字链表</h3><p><strong>有向图</strong>的另一种链式存储结构。相当于有向图的邻接表+逆邻接表。<p>由顶点结点和弧结点组成。 每个顶点结点都存储该结点对应的第一个弧头弧尾的指针；弧结点保存了其弧头弧尾指针的下一个。<pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> _ArcNode {</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> val;</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> vex_tail;</span><span class=z-comment>   //弧尾对应的结点</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> vex_head;</span><span class=z-comment>   //弧头对应的结点</span></span>
<span class=giallo-l><span class="z-storage z-type">    struct</span><span> _ArcNode tail_next;</span><span class=z-comment>  //弧尾相同的下一个</span></span>
<span class=giallo-l><span class="z-storage z-type">    struct</span><span> _ArcNode head_next;</span><span class=z-comment>  //弧头相同的下一个</span></span>
<span class=giallo-l><span>} ArcNode;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> {</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> data;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    ArcNode *first_out;</span><span class=z-comment> //出度，从该结点出发的弧</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    ArcNode *first_in;</span><span class=z-comment>  //入度，以该结点结束的弧</span></span>
<span class=giallo-l><span>} Cell;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    Cell *nodes;</span><span class=z-comment>    //顶点表</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> vex_num;</span></span>
<span class=giallo-l><span>} Graph;</span></span></code></pre><h4 id=jian-li-shi-zi-lian-biao>建立十字链表</h4><pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class=z-comment>//0. input:  &lt;u,v>, arc_val</span></span>
<span class=giallo-l><span class=z-comment>//1.生成一个弧结点，补充弧头、弧尾</span></span>
<span class=giallo-l><span class=z-comment>//2.将相应顶点表对应的first_out、first_in指针存到弧结点</span></span>
<span class=giallo-l><span class=z-comment>//3.将对应first_out、first_in更新成该弧结点地址</span></span>
<span class=giallo-l><span class="z-keyword z-operator">ArcNode *p = (ArcNode*)</span><span class="z-entity z-name z-function">malloc</span><span>(</span><span class="z-keyword z-operator z-sizeof">sizeof</span><span>(ArcNode));</span></span>
<span class=giallo-l><span class="z-keyword z-operator">p->val = arc_val;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">p->vex_tail = u;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">p->vex_head = v;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> i =</span><span class="z-entity z-name z-function"> locate</span><span>(graph, u);</span></span>
<span class=giallo-l><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> j =</span><span class="z-entity z-name z-function"> locate</span><span>(graph, v);</span></span>
<span class=giallo-l><span class="z-keyword z-operator">p->tail_next = graph.</span><span class=z-variable>nodes</span><span>[i].first_out;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">p->head_next = graph.</span><span class=z-variable>nodes</span><span>[j].first_in;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>graph.</span><span class=z-variable>nodes</span><span class="z-keyword z-operator">[i].first_out = p;</span></span>
<span class=giallo-l><span>graph.</span><span class=z-variable>nodes</span><span class="z-keyword z-operator">[j].first_in = p;</span></span></code></pre><h3 id=lin-jie-duo-zhong-biao>邻接多重表</h3><p>是<strong>无向图</strong>的另一种链式存储结构。<pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> _ArcNode {</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> mark;</span><span class=z-comment>   //标记</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> ivex, jvex;</span><span class=z-comment> //边对应的顶点</span></span>
<span class=giallo-l><span class="z-storage z-type">    struct</span><span> _ArcNode ilink, jlink;</span><span class=z-comment>   //边对应的下一个边的指针</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> val；</span><span class=z-comment>   //边对应的权值</span></span>
<span class=giallo-l><span>} ArchNode;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> {</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> data;</span><span class=z-comment>   //结点信息</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    ArcNode *first_edge;</span><span class=z-comment>    //结点对应的第一条边的地址</span></span>
<span class=giallo-l><span>} Cell;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    Cell *nodes;</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> vex_num;</span></span>
<span class=giallo-l><span>} Graph;</span></span></code></pre><h2 id=tu-de-bian-li>图的遍历</h2><p>从图中某一顶点出发访遍图中其余顶点，且使每一个顶点仅被访问一次。<p>图的遍历算法是求解图的连通性问题、拓扑排序和求关键路径等算法的基础。<p>图的搜索需要设置一个visit数组以避免同一顶点被访问多次。 深度优先搜索（DFS）、广度优先搜索（BFS）<h3 id=dfs>DFS</h3><p>是树的先根遍历的推广。<pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-storage z-type">typedef void</span><span class="z-keyword z-operator"> (*visit)(</span><span class="z-storage z-type">int</span><span> v);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">int</span><span> visited</span><span class="z-storage z-modifier">[]</span><span>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> DFSTraverse</span><span>(Graph </span><span class=z-variable>g</span><span>, visit </span><span class=z-variable>callback</span><span>) {</span></span>
<span class=giallo-l><span class=z-comment>    // 设置visited为0</span></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> i =</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; i &lt;</span><span class=z-variable> g</span><span>.</span><span class=z-variable>vex_num</span><span class="z-keyword z-operator">;++i) {</span></span>
<span class=giallo-l><span class=z-variable>        visited</span><span class="z-keyword z-operator">[i] =</span><span class="z-constant z-numeric"> 0</span><span>;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> vex =</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; vex &lt;</span><span class=z-variable> g</span><span>.</span><span class=z-variable>vex_num</span><span class="z-keyword z-operator">;++vex) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">        if</span><span class="z-keyword z-operator">(!</span><span class=z-variable>visited</span><span>[vex])</span><span class="z-entity z-name z-function"> DFS</span><span>(g, vex, callback);</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> DFS</span><span>(Graph </span><span class=z-variable>g</span><span>,</span><span class="z-storage z-type"> int</span><span class=z-variable> vex</span><span>, visit </span><span class=z-variable>callback</span><span>) {</span></span>
<span class=giallo-l><span class=z-variable>    visited</span><span class="z-keyword z-operator">[vex] =</span><span class="z-constant z-numeric"> 1</span><span>;</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    callback</span><span>(vex);</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> vex =</span><span class="z-entity z-name z-function"> first_adj_vex</span><span class="z-keyword z-operator">(g, vex); vex >=</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">;vex =</span><span class="z-entity z-name z-function"> next_adj_vex</span><span>(g, vex)) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">        if</span><span class="z-keyword z-operator">(!</span><span class=z-variable>visited</span><span>[vex])</span><span class="z-entity z-name z-function"> DFS</span><span>(g, vex, callback);</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span></code></pre><h4 id=shi-jian-fu-za-du-fen-xi>时间复杂度分析</h4><p>初始化visited数组，时间复杂度O(n)<ol><li>邻接矩阵：查找一个顶点的边/弧，时间复杂度o(n)，对于整个图时间复杂度：O(n^2)<li>邻接表：遍历n个链表可以直接得到全部弧，时间复杂度(e)，加上初始化visited数组，为O(n+e)</ol><h3 id=bfs>BFS</h3><p>类似于树的层次遍历。<pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-storage z-type">typedef void</span><span class="z-keyword z-operator"> (*visit)(</span><span class="z-storage z-type">int</span><span> v);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">int</span><span> visited</span><span class="z-storage z-modifier">[]</span><span>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> BFSTraverse</span><span>(Graph </span><span class=z-variable>g</span><span>, visit </span><span class=z-variable>callback</span><span>) {</span></span>
<span class=giallo-l><span class=z-comment>    // 设置visited为0</span></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> i =</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; i &lt;</span><span class=z-variable> g</span><span>.</span><span class=z-variable>vex_num</span><span class="z-keyword z-operator">;++i)</span><span class=z-variable> visited</span><span class="z-keyword z-operator">[i] =</span><span class="z-constant z-numeric"> 0</span><span>;</span></span>
<span class=giallo-l><span>    Queue queue;</span><span class="z-entity z-name z-function"> init_queue</span><span class="z-keyword z-operator">(&queue);</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> vex;</span></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span> (</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> i =</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; i &lt;</span><span class=z-variable> g</span><span>.</span><span class=z-variable>vex_num</span><span class="z-keyword z-operator">;++i) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">        if</span><span>(</span><span class=z-variable>visited</span><span>[i])</span><span class="z-keyword z-control"> continue</span><span>;</span></span>
<span class=giallo-l><span class=z-variable>        visited</span><span class="z-keyword z-operator">[i] =</span><span class="z-constant z-numeric"> 1</span><span>;</span><span class="z-entity z-name z-function"> callback</span><span>(vex);</span><span class=z-comment>  //先访问，再push</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">        push</span><span>(queue, i);</span></span>
<span class=giallo-l><span>        </span></span>
<span class=giallo-l><span class="z-keyword z-control">        while</span><span class="z-keyword z-operator"> (!</span><span class="z-entity z-name z-function">empty</span><span>(queue)) {</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">            pop</span><span class="z-keyword z-operator">(queue, &vex);</span></span>
<span class=giallo-l><span class="z-keyword z-control">            for</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> i =</span><span class="z-entity z-name z-function"> first_adj_vex</span><span class="z-keyword z-operator">(g, vex); i>=</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; i =</span><span class="z-entity z-name z-function"> next_adj_vex</span><span>(g, vex)) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">                if</span><span>(</span><span class=z-variable>visited</span><span>[i])</span><span class="z-keyword z-control"> continue</span><span>;</span></span>
<span class=giallo-l><span class=z-variable>                visited</span><span class="z-keyword z-operator">[i] =</span><span class="z-constant z-numeric"> 1</span><span>;</span><span class="z-entity z-name z-function"> callback</span><span>(vex);</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">                push</span><span>(queue, i); </span></span>
<span class=giallo-l><span>            }</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>}</span></span></code></pre><h2 id=tu-de-lian-tong-xing-wen-ti>图的连通性问题</h2><h3 id=wu-xiang-tu-de-lian-tong-fen-liang-he-sheng-cheng-shu>无向图的连通分量和生成树</h3><p>极小连通子图=连通图的一棵生成树（深度优先生成树、广度优先生成树） TODO<h3 id=you-xiang-tu-de-qiang-lian-tong-fen-liang>有向图的强连通分量</h3><p>TODO<h2 id=zui-xiao-sheng-cheng-shu-mst>最小生成树MST</h2><p>研究在n个结点间建立边，使得构造出的连通网代价最小，得到最小代价生成树。<h3 id=primsuan-fa>Prim算法</h3><p>时间复杂度：O(n^2)，只与结点个数有关，适用于求<strong>边稠密</strong>的网的最小生成树。<p>空间复杂度：O(n)<p>思路：将图中结点划分为已被联结的集合U和尚未联结的集合V，每次选择V中边代价最小的结点划入U，一共循环n次。需要设置一个辅助数组close_edge[vex_num]记录V中结点与U中结点最近的边（0xFFFFFFFF表示不存在边或弧，0x0表示顶点已被加入集合U）。<pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-control">#define</span><span class="z-entity z-name z-function z-preprocessor z-meta z-preprocessor"> MAX_COST (</span><span class="z-keyword z-other z-unit z-constant z-numeric">0xFFFFFFFF</span><span class="z-meta z-preprocessor">)</span></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> {</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> arc_tail;</span><span class=z-comment>   //弧尾或边</span></span>
<span class=giallo-l><span class="z-storage z-type">    unsigned int</span><span> low_cost;</span><span class=z-comment>   //最小代价（0xFFFFFFFF表示不存在边或弧，0x0表示顶点已被加入集合U）</span></span>
<span class=giallo-l><span>} CloseEdge;</span></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> Prim</span><span>(Graph </span><span class=z-variable>g</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    CloseEdge *close_edge = (CloseEdge*)</span><span class="z-entity z-name z-function">malloc</span><span>(</span><span class=z-variable>g</span><span>.</span><span class=z-variable>vex_num</span><span class="z-keyword z-operator"> *</span><span class="z-keyword z-operator z-sizeof"> sizeof</span><span>(CloseEdge));</span></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> i =</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; i &lt;</span><span class=z-variable> g</span><span>.</span><span class=z-variable>vex_num</span><span class="z-keyword z-operator">; ++i) {</span></span>
<span class=giallo-l><span class=z-variable>        close_edge</span><span class="z-keyword z-operator">[i] = MAX_COST;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class="z-keyword z-operator"> p =</span><span class="z-constant z-numeric"> 0</span><span>;</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class="z-keyword z-operator"> p_next =</span><span class="z-constant z-numeric"> 0</span><span>;</span></span>
<span class=giallo-l><span class="z-storage z-type">    unsigned int</span><span class="z-keyword z-operator"> low_cost = MAX_COST;</span></span>
<span class=giallo-l><span class=z-variable>    close_edge</span><span>[p].</span><span class=z-variable>low_cost</span><span class="z-keyword z-operator"> =</span><span class="z-constant z-numeric"> 0</span><span>;</span><span class=z-comment> //设置为0表示加入集合U，结点0已加入</span></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> i =</span><span class="z-constant z-numeric"> 1</span><span class="z-keyword z-operator">; i &lt;</span><span class=z-variable> g</span><span>.</span><span class=z-variable>vex_num</span><span class="z-keyword z-operator">; ++i) {</span><span class=z-comment>    //一次找一个边，循环n-1次</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        low_cost = MAX_COST;</span></span>
<span class=giallo-l><span class="z-keyword z-control">        for</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> j =</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; j &lt;</span><span class=z-variable> g</span><span>.</span><span class=z-variable>vex_num</span><span class="z-keyword z-operator">; ++j) {</span><span class=z-comment>    //遍历寻找顶点p（也即集合U）最短的弧</span></span>
<span class=giallo-l><span class=z-comment>            //if(g.arcs[p][j] == MAX_COST) continue;</span></span>
<span class=giallo-l><span class="z-keyword z-control">            if</span><span>(</span><span class=z-variable>g</span><span>.</span><span class=z-variable>arcs</span><span>[p][j].</span><span class=z-variable>low_cost</span><span class="z-keyword z-operator"> &lt;</span><span class=z-variable> close_edge</span><span>[j]){</span><span class=z-comment>  //更新集合U到顶点j的弧信息</span></span>
<span class=giallo-l><span class=z-variable>                close_edge</span><span>[j].</span><span class=z-variable>arc_tail</span><span class="z-keyword z-operator"> = p;</span><span class=z-comment> //是从p出发到j</span></span>
<span class=giallo-l><span class=z-variable>                close_edge</span><span>[j].</span><span class=z-variable>low_cost</span><span class="z-keyword z-operator"> =</span><span class=z-variable> g</span><span>.</span><span class=z-variable>arcs</span><span>[p][j];</span></span>
<span class=giallo-l><span>            }</span></span>
<span class=giallo-l><span class="z-keyword z-control">            if</span><span>(</span><span class=z-variable>close_edge</span><span>[j].</span><span class=z-variable>low_cost</span><span class="z-keyword z-operator"> ></span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator"> &&</span><span class=z-variable> close_edge</span><span>[j].</span><span class=z-variable>low_cost</span><span class="z-keyword z-operator"> &lt; low_cost){</span></span>
<span class=giallo-l><span class="z-keyword z-operator">                p_next = j;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">                low_cost =</span><span class=z-variable> close_edge</span><span>[j].</span><span class=z-variable>low_cost</span><span>;</span></span>
<span class=giallo-l><span>            }</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span class=z-variable>        close_edge</span><span>[p_next].</span><span class=z-variable>low_cost</span><span class="z-keyword z-operator"> =</span><span class="z-constant z-numeric"> 0</span><span>;</span><span class=z-comment>    //设置加入集合U</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        p = p_next;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span></code></pre><p>教科书：<pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> Prim</span><span>(Graph </span><span class=z-variable>g</span><span>, VertexType </span><span class=z-variable>u</span><span>) {</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class="z-keyword z-operator"> k =</span><span class="z-entity z-name z-function"> LocateVex</span><span>(g, u);</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    CloseEdge *close_edge = (CloseEdge*)</span><span class="z-entity z-name z-function">malloc</span><span>(</span><span class=z-variable>g</span><span>.</span><span class=z-variable>vex_num</span><span class="z-keyword z-operator"> *</span><span class="z-keyword z-operator z-sizeof"> sizeof</span><span>(CloseEdge));</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-variable>    close_edge</span><span>[k].</span><span class=z-variable>low_cost</span><span class="z-keyword z-operator"> =</span><span class="z-constant z-numeric"> 0</span><span>;</span><span class=z-comment> //设置顶点k加入集合U</span></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> i =</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; I &lt;</span><span class=z-variable>g</span><span>.</span><span class=z-variable>vex_num</span><span class="z-keyword z-operator">; ++i) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">        if</span><span class="z-keyword z-operator">(k != i) {</span></span>
<span class=giallo-l><span class=z-variable>            close_edge</span><span>[i].</span><span class=z-variable>arc_tail</span><span class="z-keyword z-operator"> = k;</span></span>
<span class=giallo-l><span class=z-variable>            close_edge</span><span>[i].</span><span class=z-variable>low_cost</span><span class="z-keyword z-operator"> =</span><span class=z-variable> g</span><span>.</span><span class=z-variable>arcs</span><span>[k][i];</span><span class=z-comment>  //初始设置顶点k的弧</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> i =</span><span class="z-constant z-numeric"> 1</span><span class="z-keyword z-operator">; i &lt;</span><span class=z-variable> g</span><span>.</span><span class=z-variable>vex_num</span><span class="z-keyword z-operator">; ++i) {</span><span class=z-comment>    //选择其余n-1个顶点</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        k =</span><span class="z-entity z-name z-function"> min</span><span>(close_edge);</span><span class=z-comment>    //遍历选择代价最小的顶点(且代价>0)</span></span>
<span class=giallo-l><span class=z-variable>        close_edge</span><span>[k].</span><span class=z-variable>low_cost</span><span class="z-keyword z-operator"> =</span><span class="z-constant z-numeric"> 0</span><span>;</span><span class=z-comment> //并入k到集合U</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-control">        for</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> j =</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; j &lt;</span><span class=z-variable> g</span><span>.</span><span class=z-variable>vex_num</span><span class="z-keyword z-operator">; ++j) {</span><span class=z-comment>    //遍历顶点更新到集合U的代价</span></span>
<span class=giallo-l><span class="z-keyword z-control">            if</span><span>(</span><span class=z-variable>g</span><span>.</span><span class=z-variable>arcs</span><span class="z-keyword z-operator">[k][j] &lt;</span><span class=z-variable> close_edge</span><span>[j].</span><span class=z-variable>low_cost</span><span>) {</span></span>
<span class=giallo-l><span class=z-variable>                close_edge</span><span>[j].</span><span class=z-variable>arc_tail</span><span class="z-keyword z-operator"> = k;</span></span>
<span class=giallo-l><span class=z-variable>                close_edge</span><span>[j].</span><span class=z-variable>low_cost</span><span class="z-keyword z-operator"> =</span><span class=z-variable> g</span><span>.</span><span class=z-variable>arcs</span><span>[k][j];</span></span>
<span class=giallo-l><span>            }</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span></code></pre><h3 id=kruskalsuan-fa-jia-bian-fa>Kruskal算法（加边法）</h3><p>时间复杂度：O(e * loge)，与顶点数无关，适用于求<strong>边稀疏</strong>的网的最小生成树。<p>思路：将各个顶点看作不同的集合，递增遍历边，判断边并合并顶点所在的不同集合，最终得到一个集合（连通图）。<ol><li>将边按照从小到大的顺序排序（堆排序）；<li>每次选取代价最小的边，判断对应的两个顶点是否在同一个集合内： <ol><li>若是则放弃，继续选取下一个边；<li>否则将两个顶点对应的集合合并；</ol></ol><p>使用并查集存储遍历过程中顶点与边之间的关系。<pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> {</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> tail;</span><span class=z-comment>   //弧尾</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> head;</span><span class=z-comment>   //弧头</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> val;</span><span class=z-comment>    //权值、代价</span></span>
<span class=giallo-l><span>} Edge;</span></span>
<span class=giallo-l><span class=z-comment>//1. 堆排序</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">heap_sort</span><span>(heap, g.arcs);</span><span class=z-comment>    //辅助数组1：排序好的弧</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">int</span><span> set</span><span class="z-storage z-modifier">[]</span><span class="z-keyword z-operator"> = {</span><span class="z-constant z-numeric">0</span><span>,</span><span class="z-constant z-numeric"> 1</span><span>,</span><span class="z-constant z-numeric"> 2</span><span>, ...};</span><span class=z-comment> //辅助数组2：顶点的并查集</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>//2. 遍历全部弧</span></span>
<span class=giallo-l><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> cost =</span><span class="z-constant z-numeric"> 0</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-control">for</span><span class="z-keyword z-operator">(Edge e =</span><span class="z-entity z-name z-function"> first</span><span class="z-keyword z-operator">(heap); e >=</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; e =</span><span class="z-entity z-name z-function"> next</span><span>(heap)) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">    if</span><span>(</span><span class="z-entity z-name z-function">find</span><span>(</span><span class=z-variable>e</span><span>.</span><span class=z-variable>tail</span><span class="z-keyword z-operator">) ==</span><span class="z-entity z-name z-function"> find</span><span>(</span><span class=z-variable>e</span><span>.</span><span class=z-variable>head</span><span>))</span><span class="z-keyword z-control"> continue</span><span>;</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    merge</span><span>(</span><span class=z-variable>e</span><span>.</span><span class=z-variable>tail</span><span>,</span><span class=z-variable> e</span><span>.</span><span class=z-variable>head</span><span>);</span><span class=z-comment>  //合并结点，e是使用的边</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    printf</span><span>(e);</span><span class=z-comment>  //do sth.</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    cost +=</span><span class=z-variable> e</span><span>.</span><span class=z-variable>val</span><span>;</span></span>
<span class=giallo-l><span>}</span></span></code></pre><h4 id=bing-cha-ji-shi-li>并查集示例</h4><pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-storage z-type">int</span><span> set_parent</span><span class="z-storage z-modifier">[]</span><span>;</span><span class=z-comment>  //每一个元素对应的父节点，如果没有父节点，约定为自己（也可以舍弃index0,规定0表示没有父节点）</span></span>
<span class=giallo-l><span class=z-comment>// 找顶点i所在的集合</span></span>
<span class=giallo-l><span class="z-storage z-type">int</span><span class="z-entity z-name z-function"> find</span><span>(</span><span class="z-storage z-type">int</span><span class=z-variable> i</span><span>) {</span><span class=z-comment>   //递归地寻找顶点i的父节点</span></span>
<span class=giallo-l><span class="z-keyword z-control">    if</span><span>(</span><span class=z-variable>set_parent</span><span class="z-keyword z-operator">[i] == i) {</span><span class=z-comment>    //若规定index=0表示无父节点：set_parent[i] == 0</span></span>
<span class=giallo-l><span class="z-keyword z-control">        return</span><span> i;</span></span>
<span class=giallo-l><span>    }</span><span class="z-keyword z-control">else</span><span> {</span></span>
<span class=giallo-l><span class="z-keyword z-control">        return</span><span class="z-entity z-name z-function"> find</span><span>(</span><span class=z-variable>set_parent</span><span>[i]);</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">int</span><span class="z-entity z-name z-function"> find</span><span>(</span><span class="z-storage z-type">int</span><span class=z-variable> i</span><span>) {</span><span class=z-comment>   //非递归地寻找顶点i的父节点，同时做并查集搜索的优化</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class="z-keyword z-operator"> p = i;</span></span>
<span class=giallo-l><span class="z-keyword z-control">    while</span><span>(</span><span class=z-variable>set_parent</span><span class="z-keyword z-operator">[p] != p) {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        p =</span><span class=z-variable> set_parent</span><span>[p];</span></span>
<span class=giallo-l><span class=z-variable>        set_parent</span><span class="z-keyword z-operator">[i] = p;</span><span class=z-comment>  //并查集搜索优化</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span class="z-keyword z-control">    return</span><span> p;</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>//合并i、j所在的集合</span></span>
<span class=giallo-l><span class="z-storage z-type">int</span><span class="z-entity z-name z-function"> merge</span><span>(</span><span class="z-storage z-type">int</span><span class=z-variable> i</span><span>,</span><span class="z-storage z-type"> int</span><span class=z-variable> j</span><span>) {</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class="z-keyword z-operator"> pi =</span><span class="z-entity z-name z-function"> find</span><span>(i);</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class="z-keyword z-operator"> pj =</span><span class="z-entity z-name z-function"> find</span><span>(j);</span></span>
<span class=giallo-l><span class="z-keyword z-control">    if</span><span class="z-keyword z-operator">(pi != pj)</span><span class=z-variable> set_parent</span><span class="z-keyword z-operator">[pi] = pj;</span></span>
<span class=giallo-l><span class="z-keyword z-control">    return</span><span> pj;</span></span>
<span class=giallo-l><span>}</span></span></code></pre><h2 id=you-xiang-wu-huan-tu-dagtu-ji-qi-ying-yong>有向无环图（DAG图）及其应用</h2><p>有向无环图是描述含有公共子式的表达式的有效工具。<ol><li>偏序：若集合X上的关系R是自反的、<strong>反对称的</strong>和传递的，则称R是集合X上的偏序关系。（集合中仅有部分成员之间可以比较）<li>全序：（全体成员之间均可比较）<li>拓扑有序：<li>拓扑排序：由偏序定义得到拓扑有序的操作便是拓扑排序。由某个集合上的一个偏序得到该集合上的一个全序，这个操作称之为拓扑排序。<li>AOV网(Activity On Vertex Network)：用顶点表示活动，用弧表示活动间的优先关系的有向图称为顶点表示活动的网。用于流程图设计、子工程之间的次序关系。<li>AOE网(Activity On Edge Network)：用顶点表示事件，弧表示活动，权表示活动持续时间的网，带权的有向无环图。用于估算工程完成时间、哪些活动是影响工程进度的关键。<li>关键路径：AOE网中路径长度最长的路径。</ol><h3 id=tuo-bu-pai-xu-aovwang>拓扑排序（AOV网）</h3><p>AOV网不应存在有向环，首先判定网中是否存在环：对有向图构建拓扑有序序列，若网中所有顶点都在它的拓扑有序序列中，则不存在环。<p>拓扑排序方法：<ol><li>在有向图中选一个没有前驱的顶点并输出；<li>从图中删除该顶点和所有以它为尾的弧;<li>重复上述步骤，直至全部顶点输出（有向无环图）或图中不存在无前驱的顶点（有向图中存在环）为止。</ol><p>时间复杂度：O(n + e)<p>空间复杂度：O(n)，设置辅助数组indegree[]，存储顶点的入度值，入度为0表示顶点没有前驱。另设一栈，度为0的顶点入栈。<pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class=z-comment>//采用邻接表作有向图的存储结构</span></span>
<span class=giallo-l><span class="z-storage z-type">int</span><span class="z-entity z-name z-function"> TopologicalSort</span><span>(ALGraph </span><span class=z-variable>g</span><span>) {</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class=z-variable> indegree</span><span>[</span><span class=z-variable>g</span><span>.</span><span class=z-variable>vex_num</span><span class="z-keyword z-operator">] = {</span><span class="z-constant z-numeric">0</span><span>};</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    ArcNode *p =</span><span class="z-constant z-language"> NULL</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> i =</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; i &lt;</span><span class=z-variable> g</span><span>.</span><span class=z-variable>vex_num</span><span class="z-keyword z-operator">; ++i) {</span><span class=z-comment>    //更新各个结点的入度：O(e)</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        p =</span><span class=z-variable> g</span><span>.</span><span class=z-variable>vexs</span><span>[i].</span><span class=z-variable>first_arc</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-control">        while</span><span>(p) {</span></span>
<span class=giallo-l><span class=z-variable>            indegree</span><span class="z-keyword z-operator">[i]++;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">            p =</span><span class=z-variable> p</span><span>-></span><span class=z-variable>next</span><span>;</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>    Stack s;</span><span class="z-entity z-name z-function"> init_stack</span><span class="z-keyword z-operator">(&s);</span></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> i =</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; i &lt;</span><span class=z-variable> g</span><span>.</span><span class=z-variable>vex_num</span><span class="z-keyword z-operator">; ++i) {</span><span class=z-comment>    //设置栈存储没有前驱的顶点:O(n)</span></span>
<span class=giallo-l><span class="z-keyword z-control">        if</span><span class="z-keyword z-operator">(!</span><span class=z-variable>indegree</span><span>[i])</span><span class="z-entity z-name z-function"> push</span><span class="z-keyword z-operator">(&stack, i);</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class="z-keyword z-operator"> i, count =</span><span class="z-constant z-numeric"> 0</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    ArcNode *del;</span></span>
<span class=giallo-l><span class="z-keyword z-control">    while</span><span class="z-keyword z-operator">(!</span><span class="z-entity z-name z-function">empty</span><span class="z-keyword z-operator">(&stack)) {</span><span class=z-comment> //O(e)</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">        pop</span><span class="z-keyword z-operator">(&stack, &i); count++;</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">        printf</span><span>(</span><span class=z-string>"</span><span class="z-constant z-other z-placeholder">%d</span><span class=z-string>, "</span><span>, i);</span><span class=z-comment>  //拓扑排序输出序列</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        p =</span><span class=z-variable> g</span><span>.</span><span class=z-variable>vexs</span><span>[i].</span><span class=z-variable>first_arc</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-control">        while</span><span>(p) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">            if</span><span class="z-keyword z-operator">(!(--</span><span class=z-variable>indegree</span><span>[</span><span class=z-variable>p</span><span>-></span><span class=z-variable>adjvex</span><span>])){</span><span class=z-comment>   //入度减为0</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">                push</span><span class="z-keyword z-operator">(&stack,</span><span class=z-variable> p</span><span>-></span><span class=z-variable>adjvex</span><span>);</span></span>
<span class=giallo-l><span>            }</span></span>
<span class=giallo-l><span class="z-keyword z-operator">            p =</span><span class=z-variable> p</span><span>-></span><span class=z-variable>next</span><span>;</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-control">    if</span><span class="z-keyword z-operator">(count &lt;</span><span class=z-variable> g</span><span>.</span><span class=z-variable>vex_num</span><span>)</span><span class="z-keyword z-control"> return</span><span> ERROR;</span></span>
<span class=giallo-l><span class="z-keyword z-control">    else return</span><span> OK;</span></span>
<span class=giallo-l><span>}</span></span></code></pre><h3 id=guan-jian-lu-jing-aoewang>关键路径（AOE网）</h3><ol><li>最早开始时间ve(i)：max{前驱们的最早开始时间+弧长}<li>最晚开始时间vl(i)：min{后继们的最晚开始时间-弧长}<li>时间余量： vl(i) - ve(i)<li>关键活动：ve(i) = vl(i)的活动</ol><p>关键路径上的所有活动都是关键活动<p>求事件最早开始时间同拓扑排序，求最晚开始时间利用vl(i) = vl[j] - dur&lt;i, j><p>时间复杂度：O(n + e)<p>空间复杂度：O(n)：<ol><li>使用了辅助数组indegree[]；<li>栈T存储拓扑排序的输出顺序；</ol><pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class=z-comment>//求事件（弧）最早开始时间，使用辅助数组indegree[]</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">int</span><span> vex_e</span><span class="z-storage z-modifier">[]</span><span>;</span><span class=z-comment>    //最早开始时间</span></span>
<span class=giallo-l><span class="z-storage z-type">int</span><span> vex_l</span><span class="z-storage z-modifier">[]</span><span>;</span><span class=z-comment>    //最晚开始时间</span></span>
<span class=giallo-l><span class=z-comment>// t存储拓扑排序的一个结果，用于记录结点之间的先后次序，便于找前驱</span></span>
<span class=giallo-l><span class=z-comment>// vex_e存储最早开始时间</span></span>
<span class=giallo-l><span class="z-storage z-type">int</span><span class="z-entity z-name z-function"> _TopologicalOrder</span><span>(Graph </span><span class=z-variable>g</span><span class="z-keyword z-operator">, Stack *</span><span class=z-variable>t</span><span>) {</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class=z-variable> indegree</span><span>[</span><span class=z-variable>g</span><span>.</span><span class=z-variable>vex_num</span><span>];</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    FindIndegree</span><span>(g, indegree);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-variable>    vex_e</span><span>[</span><span class=z-invalid>0..g.vex_num</span><span class="z-keyword z-operator">] =</span><span class="z-constant z-numeric"> 0</span><span>;</span><span class=z-comment>    //初始化最早开始时间全为0</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    Stack s;</span><span class="z-entity z-name z-function"> init_stack</span><span class="z-keyword z-operator">(&s);</span></span>
<span class=giallo-l><span class=z-comment>    //将入度为0的顶点push到s内</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class="z-keyword z-operator"> count =</span><span class="z-constant z-numeric"> 0</span><span>;</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> i, j;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    ArcNode *p;</span></span>
<span class=giallo-l><span class="z-keyword z-control">    while</span><span class="z-keyword z-operator">(!</span><span class="z-entity z-name z-function">empty</span><span class="z-keyword z-operator">(&s)) {</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">        pop</span><span class="z-keyword z-operator">(&s, i);</span><span class="z-entity z-name z-function"> push</span><span class="z-keyword z-operator">(&t, i); count++;</span><span class=z-comment>   //按拓扑排序顺序输出</span></span>
<span class=giallo-l><span class="z-keyword z-control">        for</span><span class="z-keyword z-operator">(ArcNode *p =</span><span class=z-variable> g</span><span>.</span><span class=z-variable>vex</span><span>[i].</span><span class=z-variable>first_arc</span><span class="z-keyword z-operator">; p; p =</span><span class=z-variable> p</span><span>-></span><span class=z-variable>next</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">            j =</span><span class=z-variable> p</span><span>-></span><span class=z-variable>adjvex</span><span>;</span><span class=z-comment>  //顶点i指向顶点j</span></span>
<span class=giallo-l><span class="z-keyword z-control">            if</span><span>(</span><span class=z-variable>p</span><span>-></span><span class=z-variable>val</span><span class="z-keyword z-operator"> +</span><span class=z-variable> vex_e</span><span class="z-keyword z-operator">[i] ></span><span class=z-variable> vex_e</span><span>[j]) {</span></span>
<span class=giallo-l><span class=z-variable>                vex_e</span><span class="z-keyword z-operator">[j] =</span><span class=z-variable> p</span><span>-></span><span class=z-variable>val</span><span class="z-keyword z-operator"> +</span><span class=z-variable> vex_e</span><span>[i];</span><span class=z-comment>   //最早开始时间取决于最晚(大)的那个</span></span>
<span class=giallo-l><span>            }</span></span>
<span class=giallo-l><span class="z-keyword z-control">            if</span><span class="z-keyword z-operator">(!(--</span><span class=z-variable>indegree</span><span>[j]))</span><span class="z-entity z-name z-function"> push</span><span class="z-keyword z-operator">(&s, j);</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-control">    if</span><span class="z-keyword z-operator">(count &lt;</span><span class=z-variable> g</span><span>.</span><span class=z-variable>vex_num</span><span>)</span><span class="z-keyword z-control"> return</span><span> ERR;</span></span>
<span class=giallo-l><span class="z-keyword z-control">    return</span><span> OK;</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">int</span><span class="z-entity z-name z-function"> criticalPath</span><span>(ALGraph </span><span class=z-variable>g</span><span>) {</span></span>
<span class=giallo-l><span>    Stack T;</span><span class="z-entity z-name z-function"> init_stack</span><span class="z-keyword z-operator">(&T);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-control">    if</span><span class="z-keyword z-operator">(!</span><span class="z-entity z-name z-function">_TopologicalOrder</span><span class="z-keyword z-operator">(g, &T))</span><span class="z-keyword z-control"> return</span><span> ERR;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-variable>    vex_l</span><span>[</span><span class=z-invalid>0..g.vex_num</span><span class="z-keyword z-operator">] =</span><span class=z-variable> vex_e</span><span>[</span><span class=z-variable>g</span><span>.</span><span class=z-variable>vex_num</span><span class="z-keyword z-operator"> -</span><span class="z-constant z-numeric"> 1</span><span>];</span><span class=z-comment> //初始化最晚开始时间全为最大值</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-operator">    ArcNode *p;</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> i, j;</span></span>
<span class=giallo-l><span class="z-keyword z-control">    while</span><span class="z-keyword z-operator">(!</span><span class="z-entity z-name z-function">empty</span><span class="z-keyword z-operator">(&T)) {</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">        pop</span><span class="z-keyword z-operator">(&T, i);</span></span>
<span class=giallo-l><span class="z-keyword z-control">        for</span><span class="z-keyword z-operator">(p =</span><span class=z-variable> g</span><span>.</span><span class=z-variable>vexs</span><span>[i].</span><span class=z-variable>first_arc</span><span class="z-keyword z-operator">; p; p =</span><span class=z-variable> p</span><span>-></span><span class=z-variable>next</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">            j =</span><span class=z-variable> p</span><span>.</span><span class=z-variable>adjvex</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-control">            if</span><span>(</span><span class=z-variable>vex_l</span><span class="z-keyword z-operator">[j] -</span><span class=z-variable> p</span><span>-></span><span class=z-variable>val</span><span class="z-keyword z-operator"> &lt;</span><span class=z-variable> vex_l</span><span>[i]) {</span></span>
<span class=giallo-l><span class=z-variable>                vex_l</span><span class="z-keyword z-operator">[i] =</span><span class=z-variable> vex_l</span><span class="z-keyword z-operator">[j] -</span><span class=z-variable> p</span><span>-></span><span class=z-variable>val</span><span>;</span><span class=z-comment>   //最晚开始时间取决于最早(小)的那个</span></span>
<span class=giallo-l><span>            }</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>    //echo vex_e[..], vex_l[..]</span></span>
<span class=giallo-l><span class="z-keyword z-control">    return</span><span> OK;</span></span>
<span class=giallo-l><span>}</span></span></code></pre><h2 id=zui-duan-lu-jing>最短路径</h2><p>一类带权有向图问题<ol><li>源点：路径上第一个顶点<li>终点：路径上最后一个顶点</ol><h3 id=cong-mou-ge-yuan-dian-dao-qi-yu-ge-ding-dian-de-zui-duan-lu-jing-dijkstradi-jie-si-te-la-suan-fa>从某个源点到其余各顶点的最短路径——Dijkstra迪杰斯特拉算法</h3><p>按路径长度递增的次序产生最短路径的方法，用于求解从源点v到其余各顶点v1、v2…的最短路径。<p><strong>v到vi的最短路径只可能是v直接到vi,或者经过了点vk到vi</strong>，可以用反证法或数学归纳法证明。<p>时间复杂度：O(n^2)<p>空间复杂度：O(n)<ol><li>设置辅助数组dis[]，表示从源点v到vi的最短路径长度（规定弧不存在时无穷）；<li>设置辅助数组in_set[]，表示顶点i是否已访问到。</ol><p>思路：<ol><li>初始时，将v到各个顶点的弧赋值到dis[]；<li>从dis中找到未访问的且距离v最短的顶点i,对于vi到各顶点vj的弧长，当且仅当dis[j] > dis[i] + arc_len&lt;vi, vj>时，更新dis到各个顶点的距离为较小的那个;<li>重复步骤2共n-1次。</ol><pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class=z-comment>//假设使用邻接矩阵</span></span>
<span class=giallo-l><span class="z-keyword z-control">#define</span><span class="z-entity z-name z-function z-preprocessor z-meta z-preprocessor"> INF (</span><span class="z-keyword z-other z-unit z-constant z-numeric">0xFFFFFFFF</span><span class="z-meta z-preprocessor">)</span></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> dijkstra</span><span>(Graph </span><span class=z-variable>g</span><span>,</span><span class="z-storage z-type"> int</span><span class=z-variable> start</span><span>,</span><span class="z-storage z-type"> int</span><span class="z-keyword z-operator"> *</span><span class=z-variable>path</span><span>) {</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class="z-keyword z-operator"> num =</span><span class=z-variable> g</span><span>.</span><span class=z-variable>vex_num</span><span>;</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class=z-variable> dis</span><span>[num];</span><span class=z-comment> // i到start的最短距离</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class=z-variable> in_set</span><span>[num];</span><span class=z-comment>  //已访问标记，访问到的结点不会再次选取</span></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> i =</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; i &lt; num;++i) {</span></span>
<span class=giallo-l><span class=z-variable>        dis</span><span class="z-keyword z-operator">[i] =</span><span class=z-variable> g</span><span>.</span><span class=z-variable>arcs</span><span>[start][i];</span></span>
<span class=giallo-l><span class=z-variable>        path</span><span class="z-keyword z-operator">[i] = start;</span><span class=z-comment>    // &lt;start, i></span></span>
<span class=giallo-l><span class=z-variable>        in_set</span><span class="z-keyword z-operator">[i] =</span><span class="z-constant z-language"> false</span><span>;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span class=z-variable>    in_set</span><span class="z-keyword z-operator">[start] =</span><span class="z-constant z-language"> true</span><span>;</span><span class=z-comment>   //初始设置start顶点已访问</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> k;</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class="z-keyword z-operator"> min = INF;</span><span class=z-comment>  //无穷</span></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> i =</span><span class="z-constant z-numeric"> 1</span><span class="z-keyword z-operator">; i &lt; num;++i) {</span><span class=z-comment>   //从1开始，循环n-1次</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        min = INF;</span></span>
<span class=giallo-l><span class="z-keyword z-control">        for</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> j =</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; j &lt; num; ++j) {</span><span class=z-comment>  //在未访问的结点集找距离start最短的顶点k </span></span>
<span class=giallo-l><span class="z-keyword z-control">            if</span><span class="z-keyword z-operator">(!</span><span class=z-variable>in_set</span><span class="z-keyword z-operator">[j] &&</span><span class=z-variable> in_set</span><span class="z-keyword z-operator">[j] &lt; min) {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">                k = j; min =</span><span class=z-variable> in_set</span><span>[j];</span></span>
<span class=giallo-l><span>            }</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span class="z-keyword z-control">        if</span><span class="z-keyword z-operator">(min == INF)</span><span class="z-keyword z-control"> break</span><span>;</span><span class=z-comment> //找不到任何可能路径，提前结束</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-variable>        in_set</span><span class="z-keyword z-operator">[k] =</span><span class="z-constant z-language"> true</span><span>;</span><span class=z-comment>   //访问顶点k，并将其放入已访问集合</span></span>
<span class=giallo-l><span class="z-keyword z-control">        for</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> j =</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; j &lt; num;++j) {</span><span class=z-comment>   //更新经结点k到达各顶点的最短路径</span></span>
<span class=giallo-l><span class="z-keyword z-control">            if</span><span>(</span><span class=z-variable>g</span><span>.</span><span class=z-variable>arcs</span><span class="z-keyword z-operator">[k][j] == INF)</span><span class="z-keyword z-control"> continue</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-control">            if</span><span>(</span><span class=z-variable>g</span><span>.</span><span class=z-variable>arcs</span><span class="z-keyword z-operator">[k][j] +</span><span class=z-variable> dis</span><span class="z-keyword z-operator">[k] &lt;</span><span class=z-variable> dis</span><span>[j]) {</span><span class=z-comment>    //如果经k更近</span></span>
<span class=giallo-l><span class=z-variable>                dis</span><span class="z-keyword z-operator">[j] =</span><span class=z-variable> g</span><span>.</span><span class=z-variable>arcs</span><span class="z-keyword z-operator">[k][j] +</span><span class=z-variable> dis</span><span>[k];</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-variable>                path</span><span class="z-keyword z-operator">[j] = k;</span><span class=z-comment>    //偷偷记下经k到j: &lt;k, i></span></span>
<span class=giallo-l><span>            }</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span></code></pre><h3 id=mei-yi-dui-ding-dian-zhi-jian-de-zui-duan-lu-jing-floydfu-luo-yi-de-suan-fa>每一对顶点之间的最短路径——Floyd弗洛伊德算法</h3><p>ps: 可以执行n次迪杰斯特拉算法，时间复杂度为O(n^3)。弗洛伊德算法的优势是代码简单，易于实现。<p>也可以用floyd算法，其思想是用加点法，借助其他顶点间接表示任意两个顶点之间的最短距离。对于顶点vk,假设存在&lt;vi, vk>, &lt;vk, vj>, 则vi与vj之间的最短距离=min{&lt;vi, vj>, &lt;vi, vk> + &lt;vk, vj>}。对于任意顶点vk（O(n)）,都可以找到以vk为中介的两个顶点（作为弧头和弧尾，O(n^2)）并获得对应的最短距离。<p>时间复杂度:O(n^3)<p>空间复杂度：O(n^2)，设置辅助数组dis[][]，用来存储当前各顶点之间的最短距离。<pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-control">#define</span><span class="z-entity z-name z-function z-preprocessor z-meta z-preprocessor"> INF (</span><span class="z-keyword z-other z-unit z-constant z-numeric">0xFFFFFFFF</span><span class="z-meta z-preprocessor">)</span></span>
<span class=giallo-l><span class="z-storage z-type">int</span><span class=z-variable> dis</span><span>[NUM][NUM];</span><span class=z-comment> //演示用，辅助数组</span></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> Floyd</span><span>(Graph </span><span class=z-variable>g</span><span>) {</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class="z-keyword z-operator"> num =</span><span class=z-variable> g</span><span>.</span><span class=z-variable>vex_num</span><span>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> i =</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; i &lt; num; ++i) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">        for</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> j =</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; j &lt; num; ++j) {</span></span>
<span class=giallo-l><span class=z-variable>            dis</span><span class="z-keyword z-operator">[i][j] =</span><span class=z-variable> g</span><span>.</span><span class=z-variable>arcs</span><span>[i][j];</span></span>
<span class=giallo-l><span class="z-keyword z-control">            if</span><span class="z-keyword z-operator">(i == j)</span><span class=z-variable> dis</span><span class="z-keyword z-operator">[i][j] =</span><span class="z-constant z-numeric"> 0</span><span>;</span><span class=z-comment>  //自己到自己为0</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> k =</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; k &lt; num; ++k) {</span><span class=z-comment>  //对全部vk</span></span>
<span class=giallo-l><span class="z-keyword z-control">        for</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> i =</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; i &lt; num; ++i) {</span><span class=z-comment>  //顶点vi</span></span>
<span class=giallo-l><span class="z-keyword z-control">            if</span><span>(</span><span class=z-variable>dis</span><span class="z-keyword z-operator">[i][k] == INF)</span><span class="z-keyword z-control"> continue</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-control">            for</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> j =</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; j &lt; num; ++j) {</span><span class=z-comment>  //顶点vj</span></span>
<span class=giallo-l><span class="z-keyword z-control">                if</span><span>(</span><span class=z-variable>dis</span><span class="z-keyword z-operator">[k][j] == INF)</span><span class="z-keyword z-control"> continue</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-control">                if</span><span>(</span><span class=z-variable>dis</span><span class="z-keyword z-operator">[i][k] +</span><span class=z-variable> dis</span><span class="z-keyword z-operator">[k][j] &lt;</span><span class=z-variable> dis</span><span>[i][j]) {</span></span>
<span class=giallo-l><span class=z-variable>                    dis</span><span class="z-keyword z-operator">[i][j] =</span><span class=z-variable> dis</span><span class="z-keyword z-operator">[i][k] +</span><span class=z-variable> dis</span><span>[k][j];</span></span>
<span class=giallo-l><span>                }</span></span>
<span class=giallo-l><span>            }</span></span>
<span class=giallo-l><span>        }</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span></code></pre></section></article></main><div id=button-container><div id=toc-floating-container><input class=toggle id=toc-toggle type=checkbox><label title="Toggle Table of Contents" class=button for=toc-toggle id=toc-button><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M414.82-193.094q-18.044 0-30.497-12.32-12.453-12.319-12.453-30.036t12.453-30.086q12.453-12.37 30.497-12.37h392.767q17.237 0 29.927 12.487 12.69 12.486 12.69 30.203 0 17.716-12.69 29.919t-29.927 12.203H414.82Zm0-244.833q-18.044 0-30.497-12.487Q371.87-462.9 371.87-480.45t12.453-29.92q12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.511 12.69 12.512 12.69 29.845 0 17.716-12.69 30.086-12.69 12.37-29.927 12.37H414.82Zm0-245.167q-18.044 0-30.497-12.32t-12.453-30.037q0-17.716 12.453-30.086 12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.486 12.69 12.487 12.69 30.203 0 17.717-12.69 29.92-12.69 12.203-29.927 12.203H414.82ZM189.379-156.681q-32.652 0-55.878-22.829t-23.226-55.731q0-32.549 23.15-55.647 23.151-23.097 55.95-23.097 32.799 0 55.313 23.484 22.515 23.484 22.515 56.246 0 32.212-22.861 54.893-22.861 22.681-54.963 22.681Zm0-245.167q-32.652 0-55.878-23.134-23.226-23.135-23.226-55.623 0-32.487 23.467-55.517t56.12-23.03q32.102 0 54.721 23.288 22.62 23.288 22.62 55.775 0 32.488-22.861 55.364-22.861 22.877-54.963 22.877Zm-.82-244.833q-32.224 0-55.254-23.288-23.03-23.289-23.03-55.623 0-32.333 23.271-55.364 23.272-23.03 55.495-23.03 32.224 0 55.193 23.288 22.969 23.289 22.969 55.622 0 32.334-23.21 55.364-23.21 23.031-55.434 23.031Z"/></svg></label><div class=toc-content><div class=toc-container><ul><li><a href=https://bieyuanxi.github.io/blog/graph/#tu>图</a> <ul><li><a href=https://bieyuanxi.github.io/blog/graph/#ji-ben-gai-nian>基本概念</a><li><a href=https://bieyuanxi.github.io/blog/graph/#tu-de-cun-chu-jie-gou>图的存储结构</a> <ul><li><a href=https://bieyuanxi.github.io/blog/graph/#lin-jie-ju-zhen>邻接矩阵</a><li><a href=https://bieyuanxi.github.io/blog/graph/#lin-jie-biao>邻接表</a><li><a href=https://bieyuanxi.github.io/blog/graph/#shi-zi-lian-biao>十字链表</a><li><a href=https://bieyuanxi.github.io/blog/graph/#lin-jie-duo-zhong-biao>邻接多重表</a></ul><li><a href=https://bieyuanxi.github.io/blog/graph/#tu-de-bian-li>图的遍历</a> <ul><li><a href=https://bieyuanxi.github.io/blog/graph/#dfs>DFS</a><li><a href=https://bieyuanxi.github.io/blog/graph/#bfs>BFS</a></ul><li><a href=https://bieyuanxi.github.io/blog/graph/#tu-de-lian-tong-xing-wen-ti>图的连通性问题</a> <ul><li><a href=https://bieyuanxi.github.io/blog/graph/#wu-xiang-tu-de-lian-tong-fen-liang-he-sheng-cheng-shu>无向图的连通分量和生成树</a><li><a href=https://bieyuanxi.github.io/blog/graph/#you-xiang-tu-de-qiang-lian-tong-fen-liang>有向图的强连通分量</a></ul><li><a href=https://bieyuanxi.github.io/blog/graph/#zui-xiao-sheng-cheng-shu-mst>最小生成树MST</a> <ul><li><a href=https://bieyuanxi.github.io/blog/graph/#primsuan-fa>Prim算法</a><li><a href=https://bieyuanxi.github.io/blog/graph/#kruskalsuan-fa-jia-bian-fa>Kruskal算法（加边法）</a></ul><li><a href=https://bieyuanxi.github.io/blog/graph/#you-xiang-wu-huan-tu-dagtu-ji-qi-ying-yong>有向无环图（DAG图）及其应用</a> <ul><li><a href=https://bieyuanxi.github.io/blog/graph/#tuo-bu-pai-xu-aovwang>拓扑排序（AOV网）</a><li><a href=https://bieyuanxi.github.io/blog/graph/#guan-jian-lu-jing-aoewang>关键路径（AOE网）</a></ul><li><a href=https://bieyuanxi.github.io/blog/graph/#zui-duan-lu-jing>最短路径</a> <ul><li><a href=https://bieyuanxi.github.io/blog/graph/#cong-mou-ge-yuan-dian-dao-qi-yu-ge-ding-dian-de-zui-duan-lu-jing-dijkstradi-jie-si-te-la-suan-fa>从某个源点到其余各顶点的最短路径——Dijkstra迪杰斯特拉算法</a><li><a href=https://bieyuanxi.github.io/blog/graph/#mei-yi-dui-ding-dian-zhi-jian-de-zui-duan-lu-jing-floydfu-luo-yi-de-suan-fa>每一对顶点之间的最短路径——Floyd弗洛伊德算法</a></ul></ul></ul></div></div></div><a title="Go to the top of the page" class=no-hover-padding href=# id=top-button> <svg viewbox="0 0 20 20" fill=currentColor><path d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z"/></svg> </a></div><span class=hidden id=copy-success> Copied! </span><span class=hidden id=copy-init> Copy code to clipboard </span><script defer src=https://bieyuanxi.github.io/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" href=https://bieyuanxi.github.io/atom.xml> <img alt=feed loading=lazy src=https://bieyuanxi.github.io/social_icons/rss.svg title=feed> </a></ul></nav><nav class=nav-navs></nav><div class=credits><small> Powered by <a href=https://www.getzola.org>Zola</a> & <a href=https://github.com/welpo/tabi>tabi</a> </small></div></section><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><h1 class=visually-hidden id=modalTitle>Search</h1><div id=modal-content><div id=searchBar><div aria-hidden=true class=search-icon><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search… role=combobox spellcheck=false><div class="close-icon interactive-icon" title="Clear search" id=clear-search role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></div></div><div id=results-container><div id=results-info><span id=zero_results> No results</span><span id=one_results> $NUMBER result</span><span id=many_results> $NUMBER results</span><span id=two_results> $NUMBER results</span><span id=few_results> $NUMBER results</span></div><div id=results role=listbox></div></div></div></div></footer>