<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="default-src 'self';font-src 'self' data:;img-src 'self' https://* data:;media-src 'self';style-src 'self';frame-src player.vimeo.com https://www.youtube-nocookie.com;connect-src 'self';script-src 'self' 'self'" http-equiv=Content-Security-Policy><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://bieyuanxi.github.io name=base><title>
Terra's Blog • C++：拷贝与移动</title><link title="Terra's Blog - Atom Feed" href=https://bieyuanxi.github.io/atom.xml rel=alternate type=application/atom+xml><link href="https://bieyuanxi.github.io/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://bieyuanxi.github.io/main.css?h=045c365e19a4d50a64bb" rel=stylesheet><meta content="light dark" name=color-scheme><meta content=拷贝是拷贝，移动是移动(晕😵 name=description><meta content=拷贝是拷贝，移动是移动(晕😵 property=og:description><meta content=C++：拷贝与移动 property=og:title><meta content=article property=og:type><meta content=en_GB property=og:locale><meta content=https://bieyuanxi.github.io/blog/cpp-copy-and-move/ property=og:url><meta content="Terra's Blog" property=og:site_name><noscript><link href=https://bieyuanxi.github.io/no_js.css rel=stylesheet></noscript><script src=https://bieyuanxi.github.io/js/initializeTheme.min.js></script><script defer src=https://bieyuanxi.github.io/js/themeSwitcher.min.js></script><script src="https://bieyuanxi.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><a href=#main-content id=skip-link>Skip to content</a><header><nav class=navbar><div class=nav-title><a class=home-title href=https://bieyuanxi.github.io/>Terra's Blog</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://bieyuanxi.github.io/blog/>blog </a><li><a class="nav-links no-hover-padding" href=https://bieyuanxi.github.io/archive/>archive </a><li><a class="nav-links no-hover-padding" href=https://bieyuanxi.github.io/tags/>tags </a><li><a class="nav-links no-hover-padding" href=https://bieyuanxi.github.io/projects/>projects </a><li class=menu-icons-container><ul class=menu-icons-group><li class="js menu-icon"><div aria-label="Click or press $SHORTCUT to open search" class="search-icon interactive-icon" title="Click or press $SHORTCUT to open search" id=search-button role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><li class="theme-switcher-wrapper js"><div aria-label="Toggle dark mode" title="Toggle dark/light mode" aria-pressed=false class=theme-switcher role=button tabindex=0></div><div aria-label="Reset mode to default" class="theme-resetter arrow" title="Reset mode to default" aria-hidden=true role=button tabindex=0></div></ul></ul></div></nav></header><div class=content id=main-content><main><article class=h-entry><h1 class="p-name article-title">C++：拷贝与移动</h1><a class="u-url u-uid" href=https://bieyuanxi.github.io/blog/cpp-copy-and-move/></a><ul class=meta><span class="hidden p-author h-card"> <a class=u-url href=https://bieyuanxi.github.io rel=author title=Terra>Terra</a> </span><li><time class=dt-published datetime=2025-12-01>1st Dec 2025</time><li title="1337 words"><span aria-hidden=true class=separator>•</span>7 min read<li class=tag><span aria-hidden=true class=separator>•</span>Tags: <li class=tag><a class=p-category href=https://bieyuanxi.github.io/tags/c/>C++</a>, <li class=tag><a class=p-category href=https://bieyuanxi.github.io/tags/kao-bei-gou-zao-han-shu/>拷贝构造函数</a>, <li class=tag><a class=p-category href=https://bieyuanxi.github.io/tags/yi-dong-gou-zao-han-shu/>移动构造函数</a>, <li class=tag><a class=p-category href=https://bieyuanxi.github.io/tags/kao-bei-fu-zhi-yun-suan-fu/>拷贝赋值运算符</a>, <li class=tag><a class=p-category href=https://bieyuanxi.github.io/tags/yi-dong-fu-zhi-yun-suan-fu/>移动赋值运算符</a></ul><p class=p-summary hidden>拷贝是拷贝，移动是移动(晕😵<section class="e-content body"><h1 id=can-kao-zi-liao>参考资料</h1><p><a href=https://cppreference.com/w/cpp/language/copy_constructor.html rel=external>Cpp Reference</a><h1 id=yi-qian-zhi-zhi-shi-zuo-zhi-vsyou-zhi>一、前置知识：左值vs右值</h1><p>理解移动语义的前提是区分左值（lvalue） 和右值（rvalue）：<blockquote><p>左值：有名字、能取地址的对象（比如变量、函数返回的引用），可以出现在赋值号左边。</blockquote><p>示例：int a = 10; 中，a 是左值。<blockquote><p>右值：没有名字、不能取地址的临时对象（比如字面量、函数返回的临时值），只能出现在赋值号右边。</blockquote><p>示例：10、a + b、string(“hello”) 都是右值。<p>C++11 引入右值引用（&&），专门绑定右值，这是移动语义的基础。<h1 id=er-kao-bei-gou-zao-han-shu>二、拷贝构造函数</h1><p><strong>拷贝构造函数</strong>（Copy Constructor）用一个已存在的对象<strong>深拷贝</strong>创建新对象（逐字节复制 + 资源重新分配），保证新对象和原对象独立，修改一个不会影响另一个。<p>额…非常抽象的描述，先来看看拷贝构造函数能为我们带来什么便利吧。<pre class="giallo z-code"><code data-lang=cpp><span class=giallo-l><span class=z-comment>// 触发拷贝构造函数：</span></span>
<span class=giallo-l><span class=z-comment>// 1. 用一个对象初始化新对象</span></span>
<span class=giallo-l><span>MyClass c1;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-operator">MyClass c2 = c1;</span><span class=z-comment>    // 写法1</span></span>
<span class=giallo-l><span class="z-entity z-name z-type">MyClass</span><span class="z-entity z-name z-function"> c3</span><span>(</span><span class="z-entity z-name z-type">c1</span><span>);</span><span class=z-comment>     // 写法2</span></span>
<span class=giallo-l><span class=z-comment>// c1、c2、c3三个对象相互独立</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>// 2. 作为函数参数按值传递</span></span></code></pre><p>嗯…似乎确实很方便。哎等等，我不定义拷贝构造函数不也一样能用吗？<p>这是因为编译器有默认的拷贝构造函数实现，如果没有显式定义，编译器会“贴心的”替我们实现一个，即简单地拷贝原对象的值（浅拷贝）。这带来了一个问题：如果我们的对象里有一个指针，它指向了一块堆内存，默认的拷贝构造函数只会把指针拷贝到新对象中，这会出现两个不同的对象指向了同一块内存的情况，如果两个对象在析构函数内释放指向的内存，就会引发<code>double free</code>，嘶…好心办坏事了属于是。<p>所以，在需要管理堆内存等外部资源的情况下，我们必须自己实现拷贝构造函数（或者禁止编译器自动生成）。常见的实现逻辑是深拷贝原对象。<pre class="giallo z-code"><code data-lang=cpp><span class=giallo-l><span class="z-storage z-type">class</span><span class="z-entity z-name z-type"> MyClass</span><span> {</span></span>
<span class=giallo-l><span class="z-storage z-type">public:</span></span>
<span class=giallo-l><span class=z-comment>    // 拷贝构造函数：</span></span>
<span class=giallo-l><span class=z-comment>    // 参数必须是 const 左值引用（const T&），</span></span>
<span class=giallo-l><span class=z-comment>    // 保证不会修改原对象，并且允许不可变对象作为参数传入</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    MyClass</span><span>(</span><span class="z-storage z-modifier">const</span><span class="z-entity z-name z-type"> MyClass</span><span class="z-storage z-modifier">&</span><span class=z-variable> other</span><span>) {</span></span>
<span class=giallo-l><span class=z-comment>        // 深拷贝逻辑：复制数据 + 重新分配资源（比如堆内存、文件句柄）</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>};</span></span></code></pre><p>默认拷贝构造函数的行为是逐成员浅拷贝。内置类型（<code>int</code>、<code>bool</code>）值拷贝完全安全；对指针 / 引用成员拷贝指针 / 引用本身（而非指向的资源）；对类成员则调用该成员的拷贝构造函数（比如 <code>std::string</code> 是深拷贝，安全；自定义资源类如果没写深拷贝，危险）。<h1 id=san-yi-dong-gou-zao-han-shu>三、移动构造函数</h1><p><strong>移动构造函数</strong>（Move Constructor）用一个右值对象<strong>浅拷贝</strong>创建新对象（“偷” 原对象的资源，而非重新分配），原对象会被置为 “空状态”（资源指针置空），避免不必要的拷贝，提升性能。<pre class="giallo z-code"><code data-lang=cpp><span class=giallo-l><span class=z-comment>// 触发移动构造函数：</span></span>
<span class=giallo-l><span class=z-comment>// 用右值初始化新对象（比如临时对象、std::move 转换的左值）</span></span>
<span class=giallo-l><span>MyClass c1;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">MyClass c2 =</span><span class="z-entity z-name z-scope-resolution"> std</span><span>::</span><span class="z-entity z-name z-function">move</span><span>(s1);</span><span class=z-comment>    // 写法1</span></span>
<span class=giallo-l><span class="z-entity z-name z-type">MyClass</span><span class="z-entity z-name z-function"> c3</span><span>(</span><span class="z-entity z-name z-scope-resolution">std</span><span>::</span><span class="z-entity z-name z-function">move</span><span>(s2));</span><span class=z-comment>     // 写法2</span></span>
<span class=giallo-l><span class=z-comment>// c1的资源已被转移给c2</span></span></code></pre><blockquote><p><code>std::move()</code> 是一个编译期的类型转换工具，不执行任何运行时的内存移动或数据拷贝操作，核心作用是将左值强制转换为右值引用，从而触发移动语义。</blockquote><p>在容器操作中，例如向<code>vector</code>放入<code>string</code>，使用移动语义可以避免深拷贝对象。<p>好吧，我承认移动语义确实很实用，那么该如何写移动构造函数呢？<pre class="giallo z-code"><code data-lang=cpp><span class=giallo-l><span class="z-storage z-type">class</span><span class="z-entity z-name z-type"> MyClass</span><span> {</span></span>
<span class=giallo-l><span class="z-storage z-type">public:</span></span>
<span class=giallo-l><span class=z-comment>    // 手动编写移动构造函数时，编译器不会自动实现拷贝构造函数</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>    // 移动构造函数：参数是非 const 右值引用（T&&）</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    MyClass</span><span>(</span><span class="z-entity z-name z-type">MyClass</span><span class="z-storage z-modifier"> &&</span><span class=z-variable>other</span><span>)</span><span class="z-storage z-modifier"> noexcept</span><span> {</span></span>
<span class=giallo-l><span class=z-comment>        // 移动逻辑：接管原对象资源 + 原对象置空</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">        println</span><span>(</span><span class=z-string>"MyClass::Move function called."</span><span>);</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>};</span></span></code></pre><blockquote><p>注：<code>noexcept</code> 是 C++11 引入的异常说明符，核心作用是:告诉编译器 / 调用者，该函数不会抛出任何异常，编译器可基于这个承诺做性能优化。如果标记了 <code>noexcept</code> 的函数实际抛出异常，程序会直接调用 <code>std::terminate</code> 终止。</blockquote><p>需要注意的是，在手动编写移动构造函数时，编译器不会自动实现拷贝构造函数。这是因为手动编写移动构造函数意味着我们需要实现资源转移，而资源转移通常都是深拷贝的，编译器默认实现的拷贝构造函数并不合适，因此没有自动生成。如果直接使用拷贝构造函数的语法，则会遇到下面的问题：<ul><li>Copy assignment operator is implicitly deleted because ‘MyClass’ has a user-declared move constructor.<li>Copy constructor is implicitly deleted because ‘MyClass’ has a user-declared move constructor.</ul><h1 id=si-kao-bei-fu-zhi-yun-suan-fu-vs-yi-dong-fu-zhi-yun-suan-fu>四、拷贝赋值运算符 vs 移动赋值运算符</h1><p>构造函数是 “创建新对象”，赋值运算符是 “给已存在的对象赋值”。<ul><li>拷贝赋值运算符（Copy Assignment Operator）<li>移动赋值运算符（Move Assignment Operator）</ul><pre class="giallo z-code"><code data-lang=cpp><span class=giallo-l><span class="z-storage z-type">class</span><span class="z-entity z-name z-type"> MyString</span><span> {</span></span>
<span class=giallo-l><span class="z-storage z-type">private:</span></span>
<span class=giallo-l><span class="z-storage z-type">    char</span><span class="z-keyword z-operator">* data;</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> len;</span></span>
<span class=giallo-l><span class="z-storage z-type">public:</span></span>
<span class=giallo-l><span class=z-comment>    // 普通构造函数</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    MyString</span><span>(</span><span class="z-storage z-modifier z-storage z-type">const char*</span><span class=z-variable> str</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        len =</span><span class="z-entity z-name z-function"> strlen</span><span>(str);</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        data =</span><span class="z-keyword z-operator z-new"> new</span><span class="z-storage z-type"> char</span><span class="z-keyword z-operator">[len +</span><span class="z-constant z-numeric"> 1</span><span>];</span><span class=z-comment> // 分配堆内存</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">        strcpy</span><span>(data, str);</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>    // 析构函数：释放资源</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    ~MyString</span><span>() {</span></span>
<span class=giallo-l><span class="z-keyword z-operator z-delete">        delete[]</span><span> data;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>    // 拷贝赋值运算符：返回值为引用（支持链式赋值）</span></span>
<span class=giallo-l><span class="z-entity z-name z-type">    MyString</span><span class="z-storage z-modifier">&</span><span class="z-keyword z-other z-operator z-entity z-name z-operator"> operator=</span><span>(</span><span class="z-storage z-modifier">const</span><span class="z-entity z-name z-type"> MyString</span><span class="z-storage z-modifier">&</span><span class=z-variable> other</span><span>) {</span></span>
<span class=giallo-l><span class=z-comment>        // 1. 防止自赋值（s = s）</span></span>
<span class=giallo-l><span class="z-keyword z-control">        if</span><span> (</span><span class="z-variable z-language">this</span><span class="z-keyword z-operator"> == &other)</span><span class="z-keyword z-control"> return</span><span class="z-keyword z-operator"> *</span><span class="z-variable z-language">this</span><span>;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>        // 2. 释放当前对象的资源</span></span>
<span class=giallo-l><span class="z-keyword z-operator z-delete">        delete[]</span><span> data;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>        // 3. 深拷贝原对象的资源</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        len =</span><span class=z-variable> other</span><span>.</span><span class=z-variable>len</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        data =</span><span class="z-keyword z-operator z-new"> new</span><span class="z-storage z-type"> char</span><span class="z-keyword z-operator">[len +</span><span class="z-constant z-numeric"> 1</span><span>];</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">        strcpy</span><span>(data,</span><span class=z-variable> other</span><span>.</span><span class=z-variable>data</span><span>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-control">        return</span><span class="z-keyword z-operator"> *</span><span class="z-variable z-language">this</span><span>;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>    // 移动赋值运算符：返回值为引用，参数为右值引用</span></span>
<span class=giallo-l><span class="z-entity z-name z-type">    MyString</span><span class="z-storage z-modifier">&</span><span class="z-keyword z-other z-operator z-entity z-name z-operator"> operator=</span><span>(</span><span class="z-entity z-name z-type">MyString</span><span class="z-storage z-modifier">&&</span><span class=z-variable> other</span><span>)</span><span class="z-storage z-modifier"> noexcept</span><span> {</span></span>
<span class=giallo-l><span class=z-comment>        // 1. 防止自赋值</span></span>
<span class=giallo-l><span class="z-keyword z-control">        if</span><span> (</span><span class="z-variable z-language">this</span><span class="z-keyword z-operator"> == &other)</span><span class="z-keyword z-control"> return</span><span class="z-keyword z-operator"> *</span><span class="z-variable z-language">this</span><span>;</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span class=z-comment>        // 2. 释放当前对象的资源</span></span>
<span class=giallo-l><span class="z-keyword z-operator z-delete">        delete[]</span><span> data;</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span class=z-comment>        // 3. 接管原对象的资源</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        len =</span><span class=z-variable> other</span><span>.</span><span class=z-variable>len</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        data =</span><span class=z-variable> other</span><span>.</span><span class=z-variable>data</span><span>;</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span class=z-comment>        // 4. 原对象置空</span></span>
<span class=giallo-l><span class=z-variable>        other</span><span>.</span><span class=z-variable>len</span><span class="z-keyword z-operator"> =</span><span class="z-constant z-numeric"> 0</span><span>;</span></span>
<span class=giallo-l><span class=z-variable>        other</span><span>.</span><span class=z-variable>data</span><span class="z-keyword z-operator"> =</span><span class="z-constant z-language"> nullptr</span><span>;</span></span>
<span class=giallo-l><span>    </span></span>
<span class=giallo-l><span class="z-keyword z-control">        return</span><span class="z-keyword z-operator"> *</span><span class="z-variable z-language">this</span><span>;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>};</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>// 使用拷贝赋值运算符</span></span>
<span class=giallo-l><span class="z-entity z-name z-type">MyString</span><span class="z-entity z-name z-function"> s1</span><span>(</span><span class=z-string>"hello"</span><span>);</span></span>
<span class=giallo-l><span class="z-entity z-name z-type">MyString</span><span class="z-entity z-name z-function"> s2</span><span>(</span><span class=z-string>"world"</span><span>);</span></span>
<span class=giallo-l><span class="z-keyword z-operator">s2 = s1;</span><span class=z-comment> // 调用拷贝赋值，s2 释放原有资源，深拷贝 s1 的资源</span></span>
<span class=giallo-l></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>// 使用移动赋值运算符</span></span>
<span class=giallo-l><span class="z-entity z-name z-type">MyString</span><span class="z-entity z-name z-function"> s1</span><span>(</span><span class=z-string>"hello"</span><span>);</span></span>
<span class=giallo-l><span>MyString s2;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">s2 =</span><span class="z-entity z-name z-scope-resolution"> std</span><span>::</span><span class="z-entity z-name z-function">move</span><span>(s1);</span><span class=z-comment> // 调用移动赋值，s2 接管 s1 的资源</span></span>
<span class=giallo-l></span></code></pre><h1 id=keng>坑！</h1><ol><li>如果没有手动定义，编译器会默认生成拷贝构造函数（浅拷贝）、拷贝赋值运算符（浅拷贝）。<li>C++11 后，如果没有手动定义拷贝 / 移动相关函数，编译器会默认生成移动构造 / 移动赋值，但如果手动定义了拷贝构造 / 拷贝赋值，默认移动函数会被禁用。<li>如果手动定义了移动构造函数，编译器会禁止自动生成拷贝构造函数。The implicitly-declared copy constructor for class T is defined as deleted if T declares a move constructor or move assignment operator.</ol><h1 id=gan-wu>感悟</h1><p>C++ 从 C 继承了 “值语义”（变量赋值 / 传参就是复制数据），为了保持这种直觉式的行为，默认给所有类生成浅拷贝构造函数，如果编译器不默认生成拷贝构造，开发者需要为每个简单类手动写空的拷贝构造，这会导致大量冗余代码。在 C++11 引入移动语义前，“拷贝” 是对象复制的唯一方式。</section></article></main><div id=button-container><div id=toc-floating-container><input class=toggle id=toc-toggle type=checkbox><label title="Toggle Table of Contents" class=button for=toc-toggle id=toc-button><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M414.82-193.094q-18.044 0-30.497-12.32-12.453-12.319-12.453-30.036t12.453-30.086q12.453-12.37 30.497-12.37h392.767q17.237 0 29.927 12.487 12.69 12.486 12.69 30.203 0 17.716-12.69 29.919t-29.927 12.203H414.82Zm0-244.833q-18.044 0-30.497-12.487Q371.87-462.9 371.87-480.45t12.453-29.92q12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.511 12.69 12.512 12.69 29.845 0 17.716-12.69 30.086-12.69 12.37-29.927 12.37H414.82Zm0-245.167q-18.044 0-30.497-12.32t-12.453-30.037q0-17.716 12.453-30.086 12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.486 12.69 12.487 12.69 30.203 0 17.717-12.69 29.92-12.69 12.203-29.927 12.203H414.82ZM189.379-156.681q-32.652 0-55.878-22.829t-23.226-55.731q0-32.549 23.15-55.647 23.151-23.097 55.95-23.097 32.799 0 55.313 23.484 22.515 23.484 22.515 56.246 0 32.212-22.861 54.893-22.861 22.681-54.963 22.681Zm0-245.167q-32.652 0-55.878-23.134-23.226-23.135-23.226-55.623 0-32.487 23.467-55.517t56.12-23.03q32.102 0 54.721 23.288 22.62 23.288 22.62 55.775 0 32.488-22.861 55.364-22.861 22.877-54.963 22.877Zm-.82-244.833q-32.224 0-55.254-23.288-23.03-23.289-23.03-55.623 0-32.333 23.271-55.364 23.272-23.03 55.495-23.03 32.224 0 55.193 23.288 22.969 23.289 22.969 55.622 0 32.334-23.21 55.364-23.21 23.031-55.434 23.031Z"/></svg></label><div class=toc-content><div class=toc-container><ul><li><a href=https://bieyuanxi.github.io/blog/cpp-copy-and-move/#can-kao-zi-liao>参考资料</a><li><a href=https://bieyuanxi.github.io/blog/cpp-copy-and-move/#yi-qian-zhi-zhi-shi-zuo-zhi-vsyou-zhi>一、前置知识：左值vs右值</a><li><a href=https://bieyuanxi.github.io/blog/cpp-copy-and-move/#er-kao-bei-gou-zao-han-shu>二、拷贝构造函数</a><li><a href=https://bieyuanxi.github.io/blog/cpp-copy-and-move/#san-yi-dong-gou-zao-han-shu>三、移动构造函数</a><li><a href=https://bieyuanxi.github.io/blog/cpp-copy-and-move/#si-kao-bei-fu-zhi-yun-suan-fu-vs-yi-dong-fu-zhi-yun-suan-fu>四、拷贝赋值运算符 vs 移动赋值运算符</a><li><a href=https://bieyuanxi.github.io/blog/cpp-copy-and-move/#keng>坑！</a><li><a href=https://bieyuanxi.github.io/blog/cpp-copy-and-move/#gan-wu>感悟</a></ul></div></div></div><a title="Go to the top of the page" class=no-hover-padding href=# id=top-button> <svg viewbox="0 0 20 20" fill=currentColor><path d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z"/></svg> </a></div><span class=hidden id=copy-success> Copied! </span><span class=hidden id=copy-init> Copy code to clipboard </span><script defer src=https://bieyuanxi.github.io/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" href=https://bieyuanxi.github.io/atom.xml> <img alt=feed loading=lazy src=https://bieyuanxi.github.io/social_icons/rss.svg title=feed> </a></ul></nav><nav class=nav-navs></nav><div class=credits><small> Powered by <a href=https://www.getzola.org>Zola</a> & <a href=https://github.com/welpo/tabi>tabi</a> </small></div></section><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><h1 class=visually-hidden id=modalTitle>Search</h1><div id=modal-content><div id=searchBar><div aria-hidden=true class=search-icon><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search… role=combobox spellcheck=false><div class="close-icon interactive-icon" title="Clear search" id=clear-search role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></div></div><div id=results-container><div id=results-info><span id=zero_results> No results</span><span id=one_results> $NUMBER result</span><span id=many_results> $NUMBER results</span><span id=two_results> $NUMBER results</span><span id=few_results> $NUMBER results</span></div><div id=results role=listbox></div></div></div></div></footer>