<!doctype html><html lang=en><head><meta charset=UTF-8><meta content="default-src 'self';font-src 'self' data:;img-src 'self' https://* data:;media-src 'self';style-src 'self';frame-src player.vimeo.com https://www.youtube-nocookie.com;connect-src 'self';script-src 'self' 'self'" http-equiv=Content-Security-Policy><meta content="width=device-width,initial-scale=1.0" name=viewport><meta content=https://bieyuanxi.github.io name=base><title>
Terra's Blog • 数组和广义表</title><link title="Terra's Blog - Atom Feed" href=https://bieyuanxi.github.io/atom.xml rel=alternate type=application/atom+xml><link href="https://bieyuanxi.github.io/custom_subset.css?h=0b9535a28bc3d5bf2321" rel=stylesheet><link href="https://bieyuanxi.github.io/main.css?h=045c365e19a4d50a64bb" rel=stylesheet><meta content="light dark" name=color-scheme><meta content=YOUR_SITE_DESCRIPTION name=description><meta content=YOUR_SITE_DESCRIPTION property=og:description><meta content=数组和广义表 property=og:title><meta content=article property=og:type><meta content=en_GB property=og:locale><meta content=https://bieyuanxi.github.io/blog/array/ property=og:url><meta content="Terra's Blog" property=og:site_name><noscript><link href=https://bieyuanxi.github.io/no_js.css rel=stylesheet></noscript><script src=https://bieyuanxi.github.io/js/initializeTheme.min.js></script><script defer src=https://bieyuanxi.github.io/js/themeSwitcher.min.js></script><script src="https://bieyuanxi.github.io/js/searchElasticlunr.min.js?h=3626c0ef99daa745b31e" defer></script><body><a href=#main-content id=skip-link>Skip to content</a><header><nav class=navbar><div class=nav-title><a class=home-title href=https://bieyuanxi.github.io/>Terra's Blog</a></div><div class=nav-navs><ul><li><a class="nav-links no-hover-padding" href=https://bieyuanxi.github.io/blog/>blog </a><li><a class="nav-links no-hover-padding" href=https://bieyuanxi.github.io/archive/>archive </a><li><a class="nav-links no-hover-padding" href=https://bieyuanxi.github.io/tags/>tags </a><li><a class="nav-links no-hover-padding" href=https://bieyuanxi.github.io/projects/>projects </a><li class=menu-icons-container><ul class=menu-icons-group><li class="js menu-icon"><div aria-label="Click or press $SHORTCUT to open search" class="search-icon interactive-icon" title="Click or press $SHORTCUT to open search" id=search-button role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><li class="theme-switcher-wrapper js"><div aria-label="Toggle dark mode" title="Toggle dark/light mode" aria-pressed=false class=theme-switcher role=button tabindex=0></div><div aria-label="Reset mode to default" class="theme-resetter arrow" title="Reset mode to default" aria-hidden=true role=button tabindex=0></div></ul></ul></div></nav></header><div class=content id=main-content><main><article class=h-entry><h1 class="p-name article-title">数组和广义表</h1><a class="u-url u-uid" href=https://bieyuanxi.github.io/blog/array/></a><ul class=meta><span class="hidden p-author h-card"> <a class=u-url href=https://bieyuanxi.github.io rel=author title=Terra>Terra</a> </span><li><time class=dt-published datetime=2023-11-01>1st Nov 2023</time><li title="1169 words"><span aria-hidden=true class=separator>•</span>6 min read<li class=tag><span aria-hidden=true class=separator>•</span>Tags: <li class=tag><a class=p-category href=https://bieyuanxi.github.io/tags/shu-zu/>数组</a>, <li class=tag><a class=p-category href=https://bieyuanxi.github.io/tags/yan-yi-biao/>广义表</a></ul><section class="e-content body"><h1 id=shu-zu-he-yan-yi-biao>数组和广义表</h1><p>数组一旦定义，它的维数和维界就不再改变。因此除了结构的初始化和销毁，数组只有存取元素和修改元素值的操作，因此采用顺序存储结构，随机存取结构。<h1 id=shu-zu-de-shun-xu-biao-shi-he-shi-xian>数组的顺序表示和实现</h1><p>对于数组，规定了维数和各维的长度，便可为其分配空间。<pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-storage z-type">typedef int</span><span> Elem;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>// array[h][m][l]</span></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    Elem *base;</span><span class=z-comment>     //映射的一维数组基址</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> dim;</span><span class=z-comment>        //维数</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class="z-keyword z-operator"> *bounds;</span><span class=z-comment>    //各维的长度，越界判断</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class="z-keyword z-operator"> *constants;</span><span class=z-comment> //各维的步长，步长 = 上一个维度的长度 * 上一个维度的步长</span></span>
<span class=giallo-l><span class="z-keyword z-operator">} Array, *Array_p;</span></span></code></pre><pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class=z-comment>// 初始化</span></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> init</span><span>(Array </span><span class=z-variable>array</span><span>,</span><span class="z-storage z-type"> int</span><span class=z-variable> dim</span><span>, ...) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">    if</span><span class="z-keyword z-operator">(dim &lt;</span><span class="z-constant z-numeric"> 1</span><span class="z-keyword z-operator"> || dim > MAX_DIMONSION)</span><span class="z-entity z-name z-function"> exit</span><span>(</span><span class="z-constant z-numeric">1</span><span>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-variable>    array</span><span>-></span><span class=z-variable>dim</span><span class="z-keyword z-operator"> = dim;</span></span>
<span class=giallo-l><span class=z-variable>    array</span><span>-></span><span class=z-variable>bounds</span><span class="z-keyword z-operator"> = (</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator">*)</span><span class="z-entity z-name z-function">malloc</span><span>(</span><span class="z-keyword z-operator z-sizeof">sizeof</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator">) * dim);</span></span>
<span class=giallo-l><span class=z-variable>    array</span><span>-></span><span class=z-variable>constants</span><span class="z-keyword z-operator"> = (</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator">*)</span><span class="z-entity z-name z-function">malloc</span><span>(</span><span class="z-keyword z-operator z-sizeof">sizeof</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator">) * dim);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-control">    if</span><span class="z-keyword z-operator">(!(</span><span class=z-variable>array</span><span>-></span><span class=z-variable>bounds</span><span class="z-keyword z-operator"> &&</span><span class=z-variable> array</span><span>-></span><span class=z-variable>constants</span><span>))</span><span class="z-entity z-name z-function"> exit</span><span>(</span><span class="z-constant z-numeric">1</span><span>);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>    va_list ap;</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    va_start</span><span>(ap, dim);</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class="z-keyword z-operator"> sum =</span><span class="z-constant z-numeric"> 1</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span> (</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> i =</span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; i &lt; dim; ++i) {</span></span>
<span class=giallo-l><span class=z-variable>        array</span><span>-></span><span class=z-variable>bounds</span><span class="z-keyword z-operator">[i] =</span><span class="z-entity z-name z-function"> va_arg</span><span>(ap,</span><span class="z-storage z-type"> int</span><span>);</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        sum *=</span><span class=z-variable> array</span><span>-></span><span class=z-variable>bounds</span><span>[i];</span></span>
<span class=giallo-l><span>    }大小;</span><span class=z-comment>  //显然最后一级数组步长为1</span></span>
<span class=giallo-l><span class="z-keyword z-control">    for</span><span> (</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator"> i = dim -</span><span class="z-constant z-numeric"> 1</span><span class="z-keyword z-operator">; i ></span><span class="z-constant z-numeric"> 0</span><span class="z-keyword z-operator">; --i) {</span></span>
<span class=giallo-l><span class=z-variable>        array</span><span>-></span><span class=z-variable>constants</span><span class="z-keyword z-operator">[i -</span><span class="z-constant z-numeric"> 1</span><span class="z-keyword z-operator">] =</span><span class=z-variable> array</span><span>-></span><span class=z-variable>constants</span><span class="z-keyword z-operator">[i] *</span><span class=z-variable> array</span><span>-></span><span class=z-variable>bounds</span><span>[i];</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-variable>    array</span><span>-></span><span class=z-variable>base</span><span class="z-keyword z-operator"> = (</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator">*)</span><span class="z-entity z-name z-function">malloc</span><span>(</span><span class="z-keyword z-operator z-sizeof">sizeof</span><span>(</span><span class="z-storage z-type">int</span><span class="z-keyword z-operator">) * sum);</span></span>
<span class=giallo-l><span class="z-keyword z-control">    if</span><span class="z-keyword z-operator">(!array)</span><span class="z-entity z-name z-function"> exit</span><span>(</span><span class="z-constant z-numeric">1</span><span>);</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">    va_end</span><span>(ap);</span></span>
<span class=giallo-l><span>}</span></span></code></pre><h1 id=ju-zhen-de-ya-suo-cun-chu>矩阵的压缩存储</h1><p>压缩存储：对多个值相同的元只分配一个存储空间；对零元不分配空间。<p>特殊矩阵：值相同的元素或者零元素在矩阵中的分部有一定规律。反之称为稀疏矩阵。<h2 id=te-shu-ju-zhen>特殊矩阵</h2><ol><li><p>三角矩阵：对称矩阵/上/下三角矩阵：为每一对对称元分配一个存储空间，n^2 -> (n+1)*n/2</p> <pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span>则对矩阵</span><span class=z-variable>A</span><span>[i][j]（i、j从1开始），一维数组</span><span class=z-variable>Array</span><span>[index], </span></span>
<span class=giallo-l><span class="z-keyword z-operator">index = (i-</span><span class="z-constant z-numeric">1</span><span class="z-keyword z-operator">)*i/</span><span class="z-constant z-numeric">2</span><span class="z-keyword z-operator">+j-</span><span class="z-constant z-numeric">1</span><span class="z-keyword z-operator"> (i >= j)</span></span>
<span class=giallo-l><span class="z-keyword z-operator">index = (j-</span><span class="z-constant z-numeric">1</span><span class="z-keyword z-operator">)*j/</span><span class="z-constant z-numeric">2</span><span class="z-keyword z-operator">+i-</span><span class="z-constant z-numeric">1</span><span class="z-keyword z-operator"> (i &lt; j)</span><span class=z-comment> //实际就是i、j互换</span></span></code></pre> <p>对上/下三角矩阵可以多存储一个常数c表示另外区域的值。</p><li><p>对角矩阵：如三对角矩阵。</p> <pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-operator">+--- i=</span><span class="z-constant z-numeric">1</span><span class="z-keyword z-operator">, j =</span><span class="z-constant z-numeric"> 1</span><span>,</span><span class="z-constant z-numeric"> 2</span></span>
<span class=giallo-l><span class="z-keyword z-operator">|</span></span>
<span class=giallo-l><span class="z-keyword z-operator">+---</span><span class="z-constant z-numeric"> 1</span><span class="z-keyword z-operator">&lt;i&lt;n, j = i-</span><span class="z-constant z-numeric">1</span><span class="z-keyword z-operator">, i, i+</span><span class="z-constant z-numeric">1</span></span>
<span class=giallo-l><span class="z-keyword z-operator">|</span></span>
<span class=giallo-l><span class="z-keyword z-operator">+--- i=n, j = i-</span><span class="z-constant z-numeric">1</span><span>, i</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-operator">index =</span><span class="z-constant z-numeric"> 3</span><span class="z-keyword z-operator">(i-</span><span class="z-constant z-numeric">1</span><span class="z-keyword z-operator">) -</span><span class="z-constant z-numeric"> 1</span><span class="z-keyword z-operator"> + (j - i) +</span><span class="z-constant z-numeric"> 1</span><span class="z-keyword z-operator"> =</span><span class="z-constant z-numeric"> 2</span><span class="z-keyword z-operator">*i + j -</span><span class="z-constant z-numeric"> 3</span></span></code></pre></ol><h2 id=xi-shu-ju-zhen>稀疏矩阵</h2><p>假设在m * n的矩阵中有t各元素不为0,令a=t/(m*n)，称a为矩阵的<strong>稀疏因子</strong>。 通常认为a&lt;=0.05时称为稀疏矩阵。<p>存储稀疏矩阵时，除了要存储值，还要存储值的位置，即用三元组(i, j, v)表示一个非零元。<p>根据对三元组表的不同表示方法，分为：三元组顺序表、行逻辑链接的顺序表、十字链表。<h3 id=san-yuan-zu-shun-xu-biao>三元组顺序表</h3><p>以顺序存储结构表示三元组表。<p>优点：按行序有序存储，便于按行顺序处理的矩阵运算。 缺点：不能按行号随机存取某一行的非零元，需要从头查找。<pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> {</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> row;</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> col;</span></span>
<span class=giallo-l><span>    Elem val;</span></span>
<span class=giallo-l><span>} Triple;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> {</span></span>
<span class=giallo-l><span>    Triple </span><span class=z-variable>data</span><span class="z-keyword z-operator">[MAXSIZE +</span><span class="z-constant z-numeric"> 1</span><span>];</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> row_num;</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> col_num;</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> total_num;</span></span>
<span class=giallo-l><span>} TSMatrix;</span></span></code></pre><h4 id=zhuan-zhi>转置</h4><p>普通矩阵的转置，O(row*col)<p>三元组两种算法：<ol><li>列序递增转置法：O(row<em>num) 适用于num &lt;&lt; row</em>col<li>一次定位快速转置法：O(row + num) 设立num[col]表，遍历三元组表得到每一列个数，时间复杂度O(num)。随后生成每一列第一个元的位置，时间复杂度O(col)。之后遍历三元组表得到转置结果。</ol><h3 id=xing-luo-ji-lian-jie-de-shun-xu-biao>行逻辑链接的顺序表</h3><p>为了随机存取<strong>任意一行</strong>的非零元，需要知道每一行的第一个非零元在三元组表中的位置。因此在三元组表基础上加入了指示行信息的辅助数组。 优点：便于随机存取任意一行的非零元。<pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> {</span></span>
<span class=giallo-l><span>    Triple </span><span class=z-variable>data</span><span class="z-keyword z-operator">[MAXSIZE +</span><span class="z-constant z-numeric"> 1</span><span>];</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span class=z-variable> row_pos</span><span class="z-keyword z-operator">[MAXRC +</span><span class="z-constant z-numeric"> 1</span><span>];</span><span class=z-comment> //记录每一行第一个元素的位置</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> row_num;</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> col_num;</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> total_num;</span></span>
<span class=giallo-l><span>} TSMatrix;</span></span></code></pre><h3 id=shi-zi-lian-biao>十字链表</h3><p>当矩阵的非零元个数和位置在操作过程中变化较大时（插入删除），不宜采用顺序存储结构来表示三元组的线性表。<p>因此采用链式存储结构表示三元组的线性表。<pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> OLNode {</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> i, j;</span></span>
<span class=giallo-l><span>    Elem val;</span></span>
<span class=giallo-l><span class="z-storage z-type">    struct</span><span class="z-keyword z-operator"> OLNode *right, *down;</span><span class=z-comment>    //记录下一个的指针，right是同一行，down是同一列</span></span>
<span class=giallo-l><span class="z-keyword z-operator">} OLNode, *OLink;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    OLink *rhead, *chead;</span></span>
<span class=giallo-l><span class="z-storage z-type">    int</span><span> row_num, col_num, total_num;</span></span>
<span class=giallo-l><span>} CrossList;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>//插入算法实现：</span></span>
<span class=giallo-l><span class=z-comment>//先在行表中插入，之后在列表中插入。</span></span>
<span class=giallo-l><span class=z-comment>// 1.行插入</span></span>
<span class=giallo-l><span class="z-keyword z-operator">OLink p = list-></span><span class=z-variable>rhead</span><span>[</span><span class=z-variable>node</span><span>-></span><span class=z-variable>i</span><span>];</span></span>
<span class=giallo-l><span class="z-keyword z-control">if</span><span class="z-keyword z-operator">(p ==</span><span class="z-constant z-language"> NULL</span><span class="z-keyword z-operator"> || p->j > node->j) {</span></span>
<span class=giallo-l><span class=z-variable>    node</span><span>-></span><span class=z-variable>right</span><span class="z-keyword z-operator"> = p;</span></span>
<span class=giallo-l><span class=z-variable>    list</span><span>-></span><span class=z-variable>rhead</span><span>[</span><span class=z-variable>node</span><span>-></span><span class=z-variable>i</span><span class="z-keyword z-operator">] = node;</span></span>
<span class=giallo-l><span>}</span><span class="z-keyword z-control"> else</span><span> {</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    OLink p =</span><span class=z-variable> list</span><span>-></span><span class=z-variable>rhead</span><span>[</span><span class=z-variable>node</span><span>-></span><span class=z-variable>i</span><span>];</span></span>
<span class=giallo-l><span class="z-keyword z-control">    while</span><span>(</span><span class=z-variable>p</span><span>-></span><span class=z-variable>right</span><span class="z-keyword z-operator"> &&</span><span class=z-variable> p</span><span>-></span><span class=z-variable>right</span><span>-></span><span class=z-variable>j</span><span class="z-keyword z-operator"> &lt;</span><span class=z-variable> node</span><span>-></span><span class=z-variable>j</span><span class="z-keyword z-operator">) p =</span><span class=z-variable> p</span><span>-></span><span class=z-variable>right</span><span>;</span><span class=z-comment>  //循环找到合适的位置</span></span>
<span class=giallo-l><span class=z-variable>    node</span><span>-></span><span class=z-variable>right</span><span class="z-keyword z-operator"> =</span><span class=z-variable> p</span><span>-></span><span class=z-variable>right</span><span>;</span></span>
<span class=giallo-l><span class=z-variable>    p</span><span>-></span><span class=z-variable>right</span><span class="z-keyword z-operator"> = node;</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l><span class=z-comment>// 2.列插入......</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>//删除算法实现：</span></span>
<span class=giallo-l><span class=z-comment>//先在行表删除，之后在列表删除</span></span>
<span class=giallo-l><span class="z-keyword z-operator">QLink del =</span><span class="z-constant z-language"> NULL</span><span>;</span></span>
<span class=giallo-l><span class=z-comment>//行表删除</span></span>
<span class=giallo-l><span class="z-keyword z-operator">OLink p = list-></span><span class=z-variable>rhead</span><span>[</span><span class=z-variable>node</span><span>-></span><span class=z-variable>i</span><span>];</span></span>
<span class=giallo-l><span class="z-keyword z-control">if</span><span class="z-keyword z-operator">(p ==</span><span class="z-constant z-language"> NULL</span><span>)</span><span class="z-keyword z-control"> return</span><span>;</span><span class=z-comment>       //是空的</span></span>
<span class=giallo-l><span class="z-keyword z-control">if</span><span class="z-keyword z-operator">(p->j == node->j) {</span><span class=z-comment>       //删除的是第一个</span></span>
<span class=giallo-l><span class="z-keyword z-operator">    del = p;</span></span>
<span class=giallo-l><span class=z-variable>    list</span><span>-></span><span class=z-variable>rhead</span><span>[</span><span class=z-variable>node</span><span>-></span><span class=z-variable>i</span><span class="z-keyword z-operator">] =</span><span class=z-variable> p</span><span>-></span><span class=z-variable>right</span><span>;</span></span>
<span class=giallo-l><span>}</span><span class="z-keyword z-control"> else</span><span> {</span><span class=z-comment>    //删除的不是第一个，设p为要删除的父结点</span></span>
<span class=giallo-l><span class="z-keyword z-control">    while</span><span>(</span><span class=z-variable>p</span><span>-></span><span class=z-variable>right</span><span class="z-keyword z-operator"> &&</span><span class=z-variable> p</span><span>-></span><span class=z-variable>right</span><span>-></span><span class=z-variable>j</span><span class="z-keyword z-operator"> !=</span><span class=z-variable> node</span><span>-></span><span class=z-variable>j</span><span class="z-keyword z-operator">) p =</span><span class=z-variable> p</span><span>-></span><span class=z-variable>right</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-control">    if</span><span>(</span><span class=z-variable>p</span><span>-></span><span class=z-variable>right</span><span>) {</span><span class=z-comment>  //如果找到了</span></span>
<span class=giallo-l><span class="z-keyword z-operator">        del =</span><span class=z-variable> p</span><span>-></span><span class=z-variable>right</span><span>;</span></span>
<span class=giallo-l><span class=z-variable>        p</span><span>-></span><span class=z-variable>right</span><span class="z-keyword z-operator"> =</span><span class=z-variable> p</span><span>-></span><span class=z-variable>right</span><span>-></span><span class=z-variable>right</span><span>;</span></span>
<span class=giallo-l><span>    }</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l><span class=z-comment>//列表删除......</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>// 最后返回del即可</span></span>
<span class=giallo-l></span></code></pre><p>在建立十字链表时，如果插入的位置随机，时间复杂度：O(total_num * max{row_num, col_num}); 如果按照行序为主序顺序插入，则时间复杂度：O(total_num)。（两个数组记录行列最后一个结点地址）<h1 id=yan-yi-biao-de-ding-yi>广义表的定义</h1><p>广义表是线性表的推广，也被称为列表(lists，用复数形式与通称的表list区别)。<p>广义表一般记作： LS = (a1, a2, …, an)，LS是表名，ai可以是单个元素（广义表的原子）也可以是广义表（广义表的子表）。<ol><li>列表的元素可以是子表，子表的元素也可以是子表。<li>列表可以为其他列表共享。<li>列表可以是一个递归的表，即列表也可以是其本身的一个子表。</ol><h2 id=ji-ben-gai-nian>基本概念</h2><ol><li>广义表：n个表元素组成的有限序列。<li>表头(Head)：称第一个元素a1为LS的表头。<li>表尾(Tail)：称其余元素组成的(a2, a3, …, an)是LS的表尾。（注意没有去掉最外一层的括号）<li>长度：最外层括号内元素的个数（第一个括号里用逗号分割出的元素的个数）。<li>深度：括号的层次最大数。</ol><h2 id=xing-zhi>性质</h2><p>任何一个非空列表其表头可能是原子，也可能是列表，而<strong>其表尾必定为列表</strong>。<pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class=z-comment>//example:</span></span>
<span class=giallo-l><span class="z-keyword z-operator">A=()</span><span class=z-comment>    //A是空表，长度为0</span></span>
<span class=giallo-l><span class="z-keyword z-operator">B=(e)</span><span class=z-comment>   //B只有一个原子，长度为1</span></span>
<span class=giallo-l><span class="z-keyword z-operator">C=(a, (b, c, d))</span><span class=z-comment>    // C长度为2,两个元素分别为原子a，子表(b, c, d)</span></span>
<span class=giallo-l><span class="z-keyword z-operator">D=(A, B, C)</span><span class=z-comment> //D长度为3，3个元素都是子表</span></span>
<span class=giallo-l><span class="z-keyword z-operator">E=(a, E)</span><span class=z-comment>    //E是递归表，长度为2</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>//列表()和列表(())不同，前者为空表，长度为0，后者长度为1</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">GetHead</span><span class="z-keyword z-operator">(B) = e;</span><span class="z-entity z-name z-function">         GetTail</span><span class="z-keyword z-operator">(B) = ();</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">GetHead</span><span class="z-keyword z-operator">(C) = a;</span><span class="z-entity z-name z-function">         GetTail</span><span class="z-keyword z-operator">(C) = ((b, c, d));</span><span class=z-comment>   //*注意这里两个括号</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">GetHead</span><span class="z-keyword z-operator">(D) = A;</span><span class="z-entity z-name z-function">         GetTail</span><span class="z-keyword z-operator">(D) = (B, C);</span></span>
<span class=giallo-l><span class="z-entity z-name z-function">GetHead</span><span class="z-keyword z-operator">((B, C)) = B;</span><span class="z-entity z-name z-function">    GetTail</span><span class="z-keyword z-operator">((B, C)) = (C);</span></span></code></pre><h2 id=yan-yi-biao-de-cun-chu-jie-gou>广义表的存储结构</h2><h3 id=yan-yi-biao-de-tou-wei-lian-biao-cun-chu-biao-shi>广义表的头尾链表存储表示</h3><ol><li>列表的表头指针，除指向空表时表头指针为空外，指向任何非空列表时，其表头指针均指向一个表结点，且该结点中的hp指向列表表头；tp指向列表表尾，tp为空代表表尾为空。<li>最高层的表结点的个数即为列表的长度。</ol><pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-storage z-type">typedef enum</span><span> {ATOM, LIST} ElemTag;</span><span class=z-comment>  //ATOM:原子；LIST: 子表</span></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef int</span><span> AtomType;</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class=z-comment>/** 广义表的头尾链表存储表示 */</span></span>
<span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> GLNode {</span></span>
<span class=giallo-l><span>    ElemTag tag;</span><span class=z-comment>    //区分原子结点还是子表结点</span></span>
<span class=giallo-l><span class="z-storage z-type">    union</span><span> {</span></span>
<span class=giallo-l><span>        AtomType atom;</span><span class=z-comment>  //原子结点的值</span></span>
<span class=giallo-l><span class="z-storage z-type">        struct</span><span> {</span><span class="z-storage z-type">struct</span><span class="z-keyword z-operator"> GLNode *hp, *tp;} ptr;</span><span class=z-comment>   //表结点的指针域</span></span>
<span class=giallo-l><span>    };</span></span>
<span class=giallo-l><span class="z-keyword z-operator">} *GList;</span><span class=z-comment>   //广义表类型</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> GetHead</span><span>(GList </span><span class=z-variable>lists</span><span class="z-keyword z-operator">, GLNode **</span><span class=z-variable>node</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">    if</span><span class="z-keyword z-operator">(lists) *node =</span><span class=z-variable> lists</span><span>-></span><span class=z-variable>ptr</span><span>.</span><span class=z-variable>hp</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-control">    else</span><span class="z-keyword z-operator"> *node =</span><span class="z-constant z-language"> NULL</span><span>;</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span class="z-storage z-type">void</span><span class="z-entity z-name z-function"> GetTail</span><span>(GList </span><span class=z-variable>lists</span><span class="z-keyword z-operator">, GLNode **</span><span class=z-variable>node</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">    if</span><span class="z-keyword z-operator">(lists) *node =</span><span class=z-variable> lists</span><span>-></span><span class=z-variable>ptr</span><span>.</span><span class=z-variable>tp</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-control">    else</span><span class="z-keyword z-operator"> *node =</span><span class="z-constant z-language"> NULL</span><span>;</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span>
<span class=giallo-l><span>ElemTag </span><span class="z-entity z-name z-function">is_lists</span><span class="z-keyword z-operator">(GLNode *</span><span class=z-variable>node</span><span>) {</span></span>
<span class=giallo-l><span class="z-keyword z-control">    if</span><span class="z-keyword z-operator">(!node || !</span><span class=z-variable>node</span><span>-></span><span class=z-variable>tag</span><span>)</span><span class="z-keyword z-control"> return</span><span class="z-constant z-numeric"> 0</span><span>;</span></span>
<span class=giallo-l><span class="z-keyword z-control">    else return</span><span class="z-constant z-numeric"> 1</span><span>;</span></span>
<span class=giallo-l><span>}</span></span>
<span class=giallo-l></span></code></pre><h3 id=yan-yi-biao-de-tuo-zhan-xian-xing-lian-biao-biao-shi>广义表的拓展线性链表表示</h3><pre class="giallo z-code"><code data-lang=c><span class=giallo-l><span class="z-keyword z-storage z-type">typedef struct</span><span> GLNode {</span></span>
<span class=giallo-l><span>    ElemTag tag;</span><span class=z-comment>    //区分原子结点还是子表结点</span></span>
<span class=giallo-l><span class="z-storage z-type">    union</span><span> {</span></span>
<span class=giallo-l><span>        AtomType atom;</span><span class=z-comment>  //原子结点的值</span></span>
<span class=giallo-l><span class="z-storage z-type">        struct</span><span class="z-keyword z-operator"> GLNode *head_ptr;</span><span class=z-comment>   //表结点的指针域</span></span>
<span class=giallo-l><span>    };</span></span>
<span class=giallo-l><span class="z-storage z-type">    struct</span><span class="z-keyword z-operator"> GLNode *tail_ptr;</span></span>
<span class=giallo-l><span class="z-keyword z-operator">} *GList;</span><span class=z-comment>   //广义表类型</span></span></code></pre></section></article></main><div id=button-container><div id=toc-floating-container><input class=toggle id=toc-toggle type=checkbox><label title="Toggle Table of Contents" class=button for=toc-toggle id=toc-button><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M414.82-193.094q-18.044 0-30.497-12.32-12.453-12.319-12.453-30.036t12.453-30.086q12.453-12.37 30.497-12.37h392.767q17.237 0 29.927 12.487 12.69 12.486 12.69 30.203 0 17.716-12.69 29.919t-29.927 12.203H414.82Zm0-244.833q-18.044 0-30.497-12.487Q371.87-462.9 371.87-480.45t12.453-29.92q12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.511 12.69 12.512 12.69 29.845 0 17.716-12.69 30.086-12.69 12.37-29.927 12.37H414.82Zm0-245.167q-18.044 0-30.497-12.32t-12.453-30.037q0-17.716 12.453-30.086 12.453-12.369 30.497-12.369h392.767q17.237 0 29.927 12.486 12.69 12.487 12.69 30.203 0 17.717-12.69 29.92-12.69 12.203-29.927 12.203H414.82ZM189.379-156.681q-32.652 0-55.878-22.829t-23.226-55.731q0-32.549 23.15-55.647 23.151-23.097 55.95-23.097 32.799 0 55.313 23.484 22.515 23.484 22.515 56.246 0 32.212-22.861 54.893-22.861 22.681-54.963 22.681Zm0-245.167q-32.652 0-55.878-23.134-23.226-23.135-23.226-55.623 0-32.487 23.467-55.517t56.12-23.03q32.102 0 54.721 23.288 22.62 23.288 22.62 55.775 0 32.488-22.861 55.364-22.861 22.877-54.963 22.877Zm-.82-244.833q-32.224 0-55.254-23.288-23.03-23.289-23.03-55.623 0-32.333 23.271-55.364 23.272-23.03 55.495-23.03 32.224 0 55.193 23.288 22.969 23.289 22.969 55.622 0 32.334-23.21 55.364-23.21 23.031-55.434 23.031Z"/></svg></label><div class=toc-content><div class=toc-container><ul><li><a href=https://bieyuanxi.github.io/blog/array/#shu-zu-he-yan-yi-biao>数组和广义表</a><li><a href=https://bieyuanxi.github.io/blog/array/#shu-zu-de-shun-xu-biao-shi-he-shi-xian>数组的顺序表示和实现</a><li><a href=https://bieyuanxi.github.io/blog/array/#ju-zhen-de-ya-suo-cun-chu>矩阵的压缩存储</a> <ul><li><a href=https://bieyuanxi.github.io/blog/array/#te-shu-ju-zhen>特殊矩阵</a><li><a href=https://bieyuanxi.github.io/blog/array/#xi-shu-ju-zhen>稀疏矩阵</a> <ul><li><a href=https://bieyuanxi.github.io/blog/array/#san-yuan-zu-shun-xu-biao>三元组顺序表</a><li><a href=https://bieyuanxi.github.io/blog/array/#xing-luo-ji-lian-jie-de-shun-xu-biao>行逻辑链接的顺序表</a><li><a href=https://bieyuanxi.github.io/blog/array/#shi-zi-lian-biao>十字链表</a></ul></ul><li><a href=https://bieyuanxi.github.io/blog/array/#yan-yi-biao-de-ding-yi>广义表的定义</a> <ul><li><a href=https://bieyuanxi.github.io/blog/array/#ji-ben-gai-nian>基本概念</a><li><a href=https://bieyuanxi.github.io/blog/array/#xing-zhi>性质</a><li><a href=https://bieyuanxi.github.io/blog/array/#yan-yi-biao-de-cun-chu-jie-gou>广义表的存储结构</a> <ul><li><a href=https://bieyuanxi.github.io/blog/array/#yan-yi-biao-de-tou-wei-lian-biao-cun-chu-biao-shi>广义表的头尾链表存储表示</a><li><a href=https://bieyuanxi.github.io/blog/array/#yan-yi-biao-de-tuo-zhan-xian-xing-lian-biao-biao-shi>广义表的拓展线性链表表示</a></ul></ul></ul></div></div></div><a title="Go to the top of the page" class=no-hover-padding href=# id=top-button> <svg viewbox="0 0 20 20" fill=currentColor><path d="M3.293 9.707a1 1 0 010-1.414l6-6a1 1 0 011.414 0l6 6a1 1 0 01-1.414 1.414L11 5.414V17a1 1 0 11-2 0V5.414L4.707 9.707a1 1 0 01-1.414 0z"/></svg> </a></div><span class=hidden id=copy-success> Copied! </span><span class=hidden id=copy-init> Copy code to clipboard </span><script defer src=https://bieyuanxi.github.io/js/copyCodeToClipboard.min.js></script></div><footer><section><nav class="socials nav-navs"><ul><li><a class="nav-links no-hover-padding social" href=https://bieyuanxi.github.io/atom.xml> <img alt=feed loading=lazy src=https://bieyuanxi.github.io/social_icons/rss.svg title=feed> </a></ul></nav><nav class=nav-navs></nav><div class=credits><small> Powered by <a href=https://www.getzola.org>Zola</a> & <a href=https://github.com/welpo/tabi>tabi</a> </small></div></section><div class="search-modal js" aria-labelledby=modalTitle id=searchModal role=dialog><h1 class=visually-hidden id=modalTitle>Search</h1><div id=modal-content><div id=searchBar><div aria-hidden=true class=search-icon><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="M784-120 532-372q-30 24-69 38t-83 14q-109 0-184.5-75.5T120-580q0-109 75.5-184.5T380-840q109 0 184.5 75.5T640-580q0 44-14 83t-38 69l252 252-56 56ZM380-400q75 0 127.5-52.5T560-580q0-75-52.5-127.5T380-760q-75 0-127.5 52.5T200-580q0 75 52.5 127.5T380-400Z"/></svg></div><input aria-controls=results-container aria-expanded=false autocomplete=off id=searchInput placeholder=Search… role=combobox spellcheck=false><div class="close-icon interactive-icon" title="Clear search" id=clear-search role=button tabindex=0><svg viewbox="0 -960 960 960" xmlns=http://www.w3.org/2000/svg><path d="m256-200-56-56 224-224-224-224 56-56 224 224 224-224 56 56-224 224 224 224-56 56-224-224-224 224Z"/></svg></div></div><div id=results-container><div id=results-info><span id=zero_results> No results</span><span id=one_results> $NUMBER result</span><span id=many_results> $NUMBER results</span><span id=two_results> $NUMBER results</span><span id=few_results> $NUMBER results</span></div><div id=results role=listbox></div></div></div></div></footer>